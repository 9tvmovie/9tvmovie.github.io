<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Trending Movies & TV Shows</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body { font-family: Arial,sans-serif; background:#111; color:#fff; margin:0; padding:20px;}
h1 { margin-bottom:20px;}
.controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:20px;align-items: baseline;}
select, button { padding:6px 12px; border-radius:5px; border:none; background:#222; color:#fff; cursor:pointer;}
.movie-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:15px;}
.movie { background:#222; padding:10px; border-radius:8px; text-align:left; transition:0.3s; position: relative; overflow: hidden; }
.movie img { width:100%; border-radius:6px; min-height:240px; object-fit:cover; cursor: pointer; display:block; }
        .movie .title { margin-top:8px; font-weight:bold; 
            display: -webkit-box; 
            -webkit-line-clamp: 1; 
            -webkit-box-orient: vertical; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            max-height: 3.2em; /* fallback to limit height (approx 2 lines) */
            line-height: 1.6em;
        }
.movie .rating {
    font-size: 13px;
    position: absolute;
    top: 13px;
    right: 13px;
    padding: 4px 6px;
    color: gold;
    border-radius: 6px;
    background: rgba(0,0,0,0.6);
    z-index: 5;
}
.movie .media-type-icon {
    position: absolute;
    top: 13px;
    left: 13px;
    font-size: 12px;
    padding: 4px 6px;
    color: #ffffff;
    border-radius: 6px;
    background: #0070ffba;
    z-index: 5;
}
.movie .status { font-size:13px; opacity:0.8; margin-top:3px; }
.movie .country { font-size:14px; opacity:0.7; }
#loader { display:none; text-align:center; margin:20px; font-size:24px; }
.pagination { margin-top:20px; text-align:center; }
.pagination button { background:#333; color:#fff; border:none; padding:6px 12px; margin:3px; cursor:pointer; border-radius:5px;}
.pagination button.active { background:#4CAF50; font-weight:bold;}
.pagination button:disabled { opacity:0.3; cursor:not-allowed;}
.pagination span { margin:0 3px; font-size:16px;}

/* Modal Styles (Netflix-like) */
#modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(4px); z-index: 1000; overflow-y: auto; }

/* Responsive modal layout: on wide screens show poster on the left and details on the right; on small screens stack vertically */
#modalContent {
    position: relative;
    max-width: 1100px;
    margin: 4% auto;
    background: #000408;
    border-radius: 10px;
    padding: 20px;
    color: #fff;
    box-shadow: 0 6px 30px rgba(0,0,0,0.6);
}

#closeModal { position: absolute; top: 12px; right: 10px; font-size: 30px; cursor: pointer; color: #fff; z-index: 2; background: transparent; border: none; }

#modalBackdrop { width: 100%; min-height: 220px; background-size: cover; background-position: center; border-radius: 8px 8px 0 0; position: absolute; margin: -20px -20px 12px -20px;filter: brightness(0.6); opacity: 0.5; }
#modalBackdrop::after { content: ''; position: absolute; inset: 0; background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0.35)); border-radius: 8px 8px 0 0; }

/* Poster (desktop uses a left column; mobile becomes inline) */
#modalPoster {
    display: block;
    border-radius: 8px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    z-index: 2;
}

#modalDetails { z-index: 2; }

/* Subtle small backdrop image under the poster */
#modalBackdropImage { display: none; }

#modalTitle { font-size: 26px; margin-bottom: 10px; }
#modalMeta { width: 100%; display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; font-size: 14px; color: #d9cd71; }
.meta-item { /*background: rgba(255,255,255,0.02);*/ padding: 6px 10px; border-bottom: 1px solid rgba(128,128,128,0.22); line-height: 1.2; }
.meta-label { opacity: 0.8; margin-right: 6px; }
.meta-value { font-weight: 600; color: #2c9dc1; }
#modalOverview { margin-bottom: 16px; font-size: 15px; line-height: 1.5; }
#modalTrailer { margin-top: 18px; }
#modalTrailer iframe { width: 100%; height: 360px; border: none; border-radius: 8px; }

/* Gallery overlay as grid of poster cards */
#galleryOverlay { display:none; position:fixed; inset:0; background: rgb(16 16 16); z-index: 2000; display:none; align-items:center; justify-content:center; }
#galleryInner { max-width: 1100px; width: calc(100% - 80px); margin: 40px auto; position: relative; padding: 20px 0; max-height: calc(100vh - 120px); overflow:auto; }
#galleryGrid { display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap:12px; align-items:start; }
#galleryGridBackdrop { display:grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap:12px; align-items:start; }
.gallery-card { background: #0b0c0d; border-radius:8px; padding:6px; display:flex; flex-direction:column; gap:6px; z-index: 1;}
.gallery-card img { width:100%; height:200px; object-fit:cover; border-radius:6px; display:block; }
.gallery-backdrop-card img {
    width: 250px;
    height: 145px;
    object-fit: cover;
    border-radius: 6px;
    display: block;
}
.gallery-card { position: relative; }
.gallery-backdrop-card { 
    position: relative;
    background: #0b0c0d;
    border-radius: 8px;
    padding: 6px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 1;
 }
.gallery-download-btn {
    position: absolute;
    right: 10px;
    bottom: 1px;
    background: rgb(33 173 243 / 0%);
    color: #fff;
    border: none;
    padding: 1px 2px 1px 20px;
    /* margin-left: 13px; */
    border-radius: 6px;
    z-index: 4;
    font-size: 14px;
    line-height: 1;
    cursor: pointer;
}
.gallery-download-btn:hover { 
    background: rgb(0 0 0 / 0%);
    transform: translateY(-1px);
 }
.gallery-card .card-meta, .gallery-backdrop-card .card-meta { 
    font-size: 12px;
    color: #ddd;
    margin-left: 4px;
    text-align: left;
 }
#galleryClose { position:fixed; right:30px; top:1px; font-size:28px; background:transparent; border:none; color:#fff; cursor:pointer;z-index: 3; }
@media (max-width: 600px) {
    #galleryGrid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap:10px; }
    .gallery-card img { height:auto; }
}

/* Responsiveness */
@media (max-width: 768px) {
    /* Force two columns on mobile */
    .movie-grid { grid-template-columns: repeat(2, 1fr); gap: 12px; }
    #modalContent { margin: 6% 6%; padding: 2px; }
    #modalBackdrop { 
        min-height: 220px;
        margin: 0 auto;
        right: 0px;
    }
    .switch {
        display: flex;
    flex-direction: column-reverse;
    }
    #galleryInner {
    display: flex;
    justify-content: center;
    width: calc(100% - 40px);
    }
    /* Stack layout: poster above details */
    #modalPoster { width: 140px; margin: 12px auto 12px auto; position: relative; display: block; }
    #modalDetails { display: block; margin: 0; padding: 8px; }
    #modalTitle { font-size: 20px; }
    #modalMeta { width: 100%; font-size: 13px; }
    #modalOverview { font-size: 14px; }
    #modalTrailer iframe { height: 220px; }
    .meta-item { padding: 6px 8px; }
    #modalBackdropImage { 
        margin: 25px auto;
    } 
}

/* Desktop grid layout */
@media (min-width: 900px) {
    #modalContent { display: grid; grid-template-columns: 240px 1fr; gap: 20px; align-items: start; padding: 24px; }
    /* backdrop spans full width above grid */
    #modalBackdrop { 
        /*grid-column: 1 / -1; */
        height: 450px;
        margin: 0px auto;
        border-radius: 8px;
     }
    /* place poster in left column overlapping the backdrop */
    #modalPoster { width: 220px; grid-column: 1; margin-top: 0px; margin-left: 10px; position: relative; }
    #modalDetails { grid-column: 2; position: relative; margin: 6px 0 0 0; padding: 6px 10px; }
    #modalTrailer iframe { height: 315px; }
    #modalBackdropImage { display: block; position: absolute; left: 33px; top: 400px; width: 220px; height: 120px; border-radius:8px; object-fit:cover; box-shadow: 0 10px 30px rgba(0,0,0,0.6); }
}

/* Desktop: arrange meta blocks side-by-side */
@media (min-width: 900px) {
    /* use a two-column grid so both meta blocks have identical width */
    .modalMC { display: grid !important; grid-template-columns: repeat(2, 1fr); gap: 20px; align-items: start; }
    #modalMeta, #modalMeta-cast { width: 100%; max-width: none; flex: none; }
    #modalMeta-cast { margin-top: 0; padding-top: 0; }
}

.modalMC {
    display: flex;
    flex-direction: row;
    gap: 20px;
    flex-wrap: wrap;
}
#modalMeta-cast {
    /* margin-top: 10px; */
    /* padding-top: 8px; */
    /* border-top: 1px solid #333; */
    font-size: 14px;
}

.cast-item {
    margin-bottom: 6px;
    /*background: rgba(255, 255, 255, 0.02);*/
    padding: 6px 10px;
    border-bottom: 1px solid rgba(128, 128, 128, 0.22);
    line-height: 1.2;
}

.cast-name {
    font-weight: 600;
    color: #d9cd71;
}

.cast-role {
    color: #2c9dc1;
    font-size: 12px;
    margin-left: 4px;
}
.as {
    font-style: italic;
    opacity: 0.8;
    color: #a4aab1;
}
</style>
</head>
<body>

<h1><a id="titleLink" href="/docs/static/">üî• Trending Movies & TV Shows</a></h1>

<div class="controls">
    <select id="mediaType" onchange="changeMedia()">
        <option value="movie">Movie</option>
        <option value="tv">TV Show</option>
    </select>
    <select id="mediaCategory" onchange="changeCategory()"></select>
    <select id="genreFilter" onchange="applyFilter()"></select>
    <select id="yearFilter" onchange="applyFilter()"></select>
    <select id="sortFilter" onchange="applyFilter()">
        <option value="popularity.desc">Popularity Desc</option>
        <option value="popularity.asc">Popularity Asc</option>
        <option value="vote_average.desc">Rating Desc</option>
        <option value="vote_average.asc">Rating Asc</option>
        <option value="combined.desc">Combined: Popularity + Rating</option>
    </select>

    <div style="margin-bottom:14px; display:flex; gap:8px; align-items:baseline;flex-wrap: wrap;">
    <input id="searchInput" type="search" placeholder="Search movies or TV..." style="width: 260px; height: 30px; flex: 1; padding: 8px; border-radius: 6px; border: 1px solid #333; background: #111; color: #fff;" onkeydown="if(event.key==='Enter')doSearch()">
    <button onclick="doSearch()">Search</button>
    <button onclick="clearSearch()">Clear</button>
    </div>

    <div style="width: 100%;margin-bottom:14px; display:flex; gap:16px; align-items:center;">
    <div style="flex:1">
        <label for="scoreSlider" style="display:block; margin-bottom:6px;">User Score: (<span id="scoreLabel">0</span>-10)</label>
        <input id="scoreSlider" type="range" min="0" max="10" step="0.5" value="0" oninput="onScoreChange(this.value)">
    </div>
    <div style="width:260px;">
        <label for="votesSlider" style="display:block; margin-bottom:6px;">Min User Votes: <span id="votesLabel">0</span></label>
        <input id="votesSlider" type="range" min="0" max="1000" step="50" value="0" oninput="onVotesChange(this.value)">
    </div>
    </div>
        
    <div style="margin-bottom:18px; display:flex; gap:8px;">
        <button onclick="applyAllFilters()" style="background:#4CAF50;">Apply Filters</button>
        <button onclick="resetFilters()" style="background:#c33;">Reset Filters</button>
        <button onclick="openHelp()" style="background:#0077ff;">Help</button>
    </div>
</div>
<div id="movieList" class="movie-grid"></div>
<div id="loader">‚è≥ Loading...</div>
<div id="pagination" class="pagination"></div>

<!-- Modal Structure -->
<div id="modal" onclick="closeModalIfOutside(event)">
    <div id="modalContent">
        <span id="closeModal" onclick="closeModal()">&times;</span>
        <div id="modalBackdrop"></div>
        <img id="modalPoster" src="" alt="">
        <img id="modalBackdropImage" src="" alt="" aria-hidden="true">
        <div id="modalDetails">
            <h2 id="modalTitle"></h2>
            <div class="switch">
            <div class="modalMC">
            <div id="modalMeta"></div>
            <div id="modalMeta-cast"></div>
            </div>
            <!-- AI Generate button and result -->
            <div style="margin-top:12px; display:flex; gap:8px; align-items:center;flex-wrap: wrap;">
                <select id="aiProviderSelect" onchange="onProviderChange()" style="height:34px; background:#071018; color:#fff; border:1px solid #333; padding:4px; border-radius:6px;">
                    <option value="openai">OpenAI</option>
                    <option value="gemini">Gemini</option>
                </select>
                <select id="aiModelSelect" style="width: 155px;height:34px; background:#071018; color:#fff; border:1px solid #333; padding:4px; border-radius:6px; display:none;">
                    <option value="">Gemini model</option>
                </select>
                <button id="aiGenerateBtn-tiktok" onclick="generateFromModal('tiktok')" style="background:#00a2ff;">‚ú® Generate (TikTok)</button>
                <button id="aiGenerateBtn-youtube" onclick="generateFromModal('youtube')" style="background:#ff0050;">‚ú® Generate (YouTube)</button>
                <div style="display:flex; gap:8px; align-items:center; margin-left:8px;">
                    <input id="aiPrimaryKeyword" type="text" placeholder="Primary keyword" style="height:32px; padding:6px; width:180px; background:#071018; color:#fff; border:1px solid #333; border-radius:6px;">
                    <input id="aiTone" type="text" placeholder="Tone (energetic, dramatic)" style="height:32px; padding:6px; width:160px; background:#071018; color:#fff; border:1px solid #333; border-radius:6px;">
                    <input id="aiVariants" type="number" min="1" max="5" value="1" style="height:32px; width:70px; padding:6px; background:#071018; color:#fff; border:1px solid #333; border-radius:6px; text-align:center;">
                </div>
                <div id="aiSuggestions" style="display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; align-items:flex-start;">
                    <div style="min-width:220px;">
                        <div style="color:#9ee7a8; font-size:12px; margin-bottom:6px;">Keyword suggestions</div>
                        <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
                            <div style="font-size:12px; color:#ccc;">Quick suggestions</div>
                            <label style="margin-left:8px; font-size:12px; display:flex; align-items:center; gap:6px;">
                                <input id="useAISuggest" type="checkbox"> Use AI suggestions
                            </label>
                            <button id="fetchAISuggestBtn" type="button" style="margin-left:8px; height:28px; background:#254; color:#fff; border-radius:6px; border:0; padding:4px 8px; cursor:pointer;">Fetch AI suggestions</button>
                        </div>
                        <div id="aiKeywordSuggestions" style="display:flex; gap:6px; flex-wrap:wrap; max-width:560px;">
                        </div>
                    </div>
                    <div style="min-width:180px;">
                        <div style="color:#9ee7a8; font-size:12px; margin-bottom:6px;">Tone suggestions</div>
                        <div id="aiToneSuggestions" style="display:flex; gap:6px; flex-wrap:wrap;">
                        </div>
                    </div>
                </div>
                <div id="aiResult" style="margin-top:10px; display:none; background:#071018; padding:10px; border-radius:6px;">
                    <h3 id="aiResultTitle" style="margin:0 0 6px 0; color:#ffd36b;"></h3>
                    <p id="aiResultDescription" style="margin:0 0 6px 0; color:#ddd;"></p>
                    <p id="aiResultHashtags" style="margin:0; color:#9ee7a8;"></p>
                </div>
            </div>
            </div>
            <p id="modalOverview"></p>
             
            <div id="modalTrailer"></div>
           
            <div id="galleryOverlay" aria-hidden="true">
                <div id="galleryInner">
                    <button id="galleryClose" onclick="closeGallery()">&times;</button>
                    <div id="galleryGrid" role="list"></div>
                    <div id="galleryGridBackdrop" role="list" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Help Modal -->
<div id="helpModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:2000; overflow:auto;">
    <div style="max-width:900px; margin:3% auto; background:#0f1113; color:#fff; padding:20px; border-radius:8px; box-shadow:0 6px 30px rgba(0,0,0,0.7);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h2 style="margin:0;">Bantuan ‚Äî Cara Menggunakan</h2>
            <button onclick="closeHelp()" style="background:transparent;border:none;color:#fff;font-size:28px;cursor:pointer">&times;</button>
        </div>

        <div style="line-height:1.5; font-size:14px; color:#ddd;">
            <p>Halaman ini menampilkan daftar film dan acara TV trending dari TMDB. Berikut panduan fitur dan langkah penggunaan:</p>

            <h3 style="margin-top:8px;color: #1595e3;">1. Pilih Tipe Media</h3>
            <p>Gunakan dropdown <strong>Movie</strong> atau <strong>TV Show</strong> untuk berpindah antara daftar film dan acara TV.</p>

            <h3 style="color: #1595e3;">2. Kategori</h3>
            <p>Pilih kategori (mis. Popular, Now Playing, Upcoming, Top Rated) untuk melihat subset yang sesuai.</p>

            <h3 style="color: #1595e3;">3. Filter Genre & Tahun</h3>
            <p>Pilih genre dan tahun rilis/penayangan untuk mempersempit hasil.</p>

            <h3 style="color: #1595e3;">4. Pencarian</h3>
            <p>Ketik kata kunci pada kotak pencarian lalu tekan <strong>Enter</strong> atau klik <strong>Search</strong>. Untuk mengembalikan daftar default klik <strong>Clear</strong>.</p>

            <h3 style="color: #1595e3;">5. Sort / Urutkan</h3>
            <p>Gunakan dropdown <strong>Sort</strong> untuk mengurutkan berdasarkan popularitas, rating, atau opsi <strong>Combined</strong> (gabungan Popularity + Rating).</p>
            <p><em>Combined</em> menggunakan perhitungan internal: <code>score = popularity + (vote_average √ó 10)</code>. Pilih <code>Combined: ...</code> untuk hasil yang menyeimbangkan popularitas dan rating.</p>

            <h3 style="color: #1595e3;">6. User Score & Minimum Votes</h3>
            <p>Gunakan slider <strong style="color:#2c9dc1">User Score</strong> (0‚Äì10) untuk memfilter hanya item dengan rating minimal yang Anda inginkan. Atur <strong>Minimum User Votes</strong> untuk hanya menampilkan item dengan jumlah suara minimal.</p>
            <p>Contoh: jika User Score = 5 ‚Üí hasil menampilkan item dengan rating 5‚Äì10. Jika User Score = 0 ‚Üí menampilkan 0‚Äì10 (seluruh range).</p>
            <p>Bagaimana mekanismenya di aplikasi (terjadi jika Anda set <strong style="color:#2c9dc1">"Minimum User Votes"</strong> ke 500): </p>
<p>Untuk mode Discover (ketika tidak sedang melakukan pencarian): </p>
<li>Aplikasi menambahkan parameter query ke TMDB: vote_count.gte=500.</li>
<li>Filter dilakukan server-side oleh TMDB ‚Üí hasil yang dikembalikan sudah memenuhi ambang 500 suara.</li>
<li>Keuntungan: hasil konsisten, sedikit sampel tidak relevan, tidak perlu memfilter lagi di klien.</li>
<p>Untuk mode Search (ketika ada kata kunci di kotak pencarian): </p>
<li>Aplikasi memakai endpoint search TMDB yang tidak menerima vote_count.gte. </li>
<li>Setelah menerima halaman hasil (biasanya 20 item), aplikasi memfilter secara lokal: hanya memperlihatkan item dalam halaman yang punya vote_count >= 500. </li>
<li>Implikasi: jika banyak hasil pada halaman itu punya kurang dari 500 suara, daftar yang terlihat bisa berkurang drastis (atau kosong) ‚Äî aplikasi tidak otomatis mengambil halaman tambahan untuk memenuhi ambang itu. </li>
<p>Kualitas vs. Coverage: </p>
<li>Ambang tinggi (500) menaikkan kemungkinan rating lebih "stabil" dan mengurangi noise dari sedikit suara. </li>
<li>Tapi mem-bias-kan hasil terhadap film/acara populer dan lama; karya baru, indie, atau regional seringkali tersingkir walau berkualitas. </li>
<p>Pada search: karena filter hanya di-klien, Anda mungkin melihat sedikit atau nol hasil untuk kata kunci tertentu walau sebenarnya ada item relevan di halaman lain.</p>
<p>Performa/kuota: </p>
<li>Untuk Discover: server-side filter mengurangi jumlah item yang Anda tampilkan sehingga biasanya efisien. </li>
<li>Untuk Search: memfilter di-klien tidak menambah kuota, tapi bisa membuat UX terasa kosong; solusi lain membutuhkan permintaan tambahan (paging) atau logika berbeda. </li>

            <h3 style="color: #1595e3;">7. Apply / Reset</h3>
            <p>Setelah mengubah beberapa kontrol, klik <strong>Apply Filters</strong> untuk menerapkan semua sekaligus. Klik <strong>Reset Filters</strong> untuk mengembalikan pengaturan ke default.</p>

            <h3 style="color: #1595e3;">8. Melihat Detail</h3>
            <p>Klik poster sebuah item untuk membuka modal detail yang memuat:</p>
            <ul>
                <li>Rating (avg / jumlah suara)</li>
                <li>Genre</li>
                <li>Director (untuk movie) atau Created By (untuk TV)</li>
                <li>Production companies</li>
                <li>Cast (5 nama pertama)</li>
                <li>Country, Language, Duration/Seasons, Released</li>
                <li>Trailer (jika tersedia)</li>
            </ul>

            <h3 style="color: #1595e3;">9. Kolom Country</h3>
            <p>Di daftar, country menampilkan kode ISO (mis. <code>us</code>) bila tersedia. Detail modal menampilkan nama negara penuh.</p>

            <h3 style="color: #1595e3;">10. Catatan Performa & Kuota API</h3>
            <p>Daftar film meminta data detail per item untuk menampilkan beberapa field (mis. production_countries). Ini menambah jumlah request (¬±20 request per halaman) dan dapat memperlambat pemuatan serta menggunakan kuota TMDB lebih cepat. Jika Anda ingin performa lebih cepat, pilih salah satu opsi:</p>
            <ul>
                <li>Nonaktifkan pengambilan detail otomatis dan ambil detail hanya saat membuka modal.</li>
                <li>Gunakan caching di sisi klien atau server untuk menyimpan detail yang sudah pernah diambil.</li>
                <li>Gunakan lazy-load: ambil negara hanya saat item terlihat atau saat hover.</li>
            </ul>

            <h3 style="color: #1595e3;">11. Tips Penggunaan</h3>
            <ul>
                <li>Untuk cepat menemukan film populer berkualitas, gunakan <strong>Combined</strong> + atur Minimum User Votes tinggi (mis. 500).</li>
                <li>Jika hasil terlalu sedikit, turunkan Minimum User Votes atau User Score.</li>
                <li>Gunakan filter genre + tahun untuk menemukan film sesuai selera.</li>
            </ul>

            <p style="margin-top:12px; color:#ccc;">Jika Anda mau, saya bisa menambahkan: tombol toggle untuk mematikan detail-per-item (untuk performa), caching sederhana, atau bantuan tooltips singkat di kontrol.</p>
        </div>
    </div>
</div>

<script>
const API_KEY = "aa39650b8e660d5046678ac425688903";
// API base (Cloudflare Worker) - update to your worker URL
const API_BASE = "https://trend.salsabiladepi31.workers.dev";
let currentPage=1, maxPage=1, mediaType='movie', mediaCategory='popular';
let selectedGenre='', selectedYear='', selectedSort='popularity.desc';
let searchQuery = '';
let minUserScore = 0; // 0..10
let minUserVotes = 0; // minimum vote_count

const categories = {
    movie:[{value:'popular',text:'Popular'},{value:'now_playing',text:'Now Playing'},{value:'upcoming',text:'Upcoming'},{value:'top_rated',text:'Top Rated'}],
    tv:[{value:'popular',text:'Popular'},{value:'airing_today',text:'Airing Today'},{value:'on_the_air',text:'On TV'},{value:'top_rated',text:'Top Rated'}]
};

const movieGenres={28:"Action",12:"Adventure",16:"Animation",35:"Comedy",80:"Crime",99:"Documentary",18:"Drama",10751:"Family",14:"Fantasy",36:"History",27:"Horror",10402:"Music",9648:"Mystery",10749:"Romance",878:"Science Fiction",10770:"TV Movie",53:"Thriller",10752:"War",37:"Western"};
const tvGenres={10759:"Action & Adventure",16:"Animation",35:"Comedy",80:"Crime",99:"Documentary",18:"Drama",10751:"Family",10762:"Kids",9648:"Mystery",10763:"News",10764:"Reality",10765:"Sci-Fi & Fantasy",10766:"Soap",10767:"Talk",10768:"War & Politics",37:"Western"};

function updateCategoryDropdown(){
    const catSelect=document.getElementById('mediaCategory');
    catSelect.innerHTML='';
    categories[mediaType].forEach(cat=>{
        const opt=document.createElement('option');
        opt.value=cat.value; opt.text=cat.text;
        catSelect.appendChild(opt);
    });
    mediaCategory=catSelect.value;
}

function updateGenreDropdown(){
    const genreSelect=document.getElementById('genreFilter'); genreSelect.innerHTML='<option value="">All Genres</option>';
    const genres=mediaType==='movie'? movieGenres:tvGenres;
    Object.entries(genres).forEach(([id,name])=>{
        const opt=document.createElement('option'); opt.value=id; opt.text=name; genreSelect.appendChild(opt);
    });
    selectedGenre='';
}

function updateYearDropdown(){
    const yearSelect=document.getElementById('yearFilter'); yearSelect.innerHTML='<option value="">All Years</option>';
    const currentYear=(new Date()).getFullYear();
    for(let y=currentYear;y>=1950;y--){
        const opt=document.createElement('option'); opt.value=y; opt.text=y; yearSelect.appendChild(opt);
    }
    selectedYear='';
}

updateCategoryDropdown(); updateGenreDropdown(); updateYearDropdown(); loadMedia(currentPage);

async function loadMedia(page){
    document.getElementById('loader').style.display='block';
    let url="";
    const params=new URLSearchParams();
    if(selectedGenre) params.append('with_genres',selectedGenre);
    if(selectedYear){ if(mediaType==='movie') params.append('primary_release_year',selectedYear); else params.append('first_air_date_year',selectedYear);}    
    if(selectedSort && !selectedSort.startsWith('combined')) params.append('sort_by',selectedSort);

    if (typeof minUserScore === 'number' && minUserScore > 0) {
        params.append('vote_average.gte', String(minUserScore));
    }
    params.append('vote_average.lte', '10');
    if (typeof minUserVotes === 'number' && minUserVotes > 0) {
        params.append('vote_count.gte', String(minUserVotes));
    }

    if (searchQuery) {
        url = `https://api.themoviedb.org/3/search/${mediaType}?api_key=${API_KEY}&query=${encodeURIComponent(searchQuery)}&page=${page}`;
    } else {
        if(mediaType==='movie'){
            if(['popular','top_rated'].includes(mediaCategory) || selectedGenre || selectedYear){
                url=`https://api.themoviedb.org/3/discover/movie?api_key=${API_KEY}&page=${page}&sort_by=${mediaCategory==='top_rated'?'vote_average.desc':'popularity.desc'}`;
                url += '&'+params.toString();
            } else if(mediaCategory==='now_playing'){
                url=`https://api.themoviedb.org/3/movie/now_playing?api_key=${API_KEY}&page=${page}`;
            } else if(mediaCategory==='upcoming'){
                url=`https://api.themoviedb.org/3/movie/upcoming?api_key=${API_KEY}&page=${page}`;
            }
        } else {
            if(['popular','top_rated'].includes(mediaCategory) || selectedGenre || selectedYear){
                url=`https://api.themoviedb.org/3/discover/tv?api_key=${API_KEY}&page=${page}&sort_by=${mediaCategory==='top_rated'?'vote_average.desc':'popularity.desc'}`;
                url += '&'+params.toString();
            } else if(mediaCategory==='airing_today'){
                url=`https://api.themoviedb.org/3/tv/airing_today?api_key=${API_KEY}&page=${page}`;
            } else if(mediaCategory==='on_the_air'){
                url=`https://api.themoviedb.org/3/tv/on_the_air?api_key=${API_KEY}&page=${page}`;
            }
        }
    }

    try{
        const res=await fetch(url);
        const data=await res.json();
        maxPage=data.total_pages>500?500:data.total_pages;

        let results = data.results || [];

        if (selectedSort && selectedSort.startsWith('combined')) {
            const desc = selectedSort.endsWith('.desc');
            results.sort((a,b) => {
                const score = (item) => (item.popularity || 0) + ((item.vote_average || 0) * 10);
                const sa = score(a);
                const sb = score(b);
                return desc ? (sb - sa) : (sa - sb);
            });
        }

        const minScore = typeof minUserScore === 'number' ? minUserScore : 0;
        const minVotes = typeof minUserVotes === 'number' ? minUserVotes : 0;
        if (minScore > 0 || minVotes > 0) {
            results = results.filter(r => {
                const avg = r.vote_average != null ? r.vote_average : 0;
                const vc = r.vote_count != null ? r.vote_count : 0;
                return avg >= minScore && avg <= 10 && vc >= minVotes;
            });
        }

        if(mediaType === 'movie'){
            const detailPromises = results.map(r =>
                fetch(`https://api.themoviedb.org/3/movie/${r.id}?api_key=${API_KEY}`)
                    .then(res => res.json())
                    .catch(() => null)
            );
            const details = await Promise.all(detailPromises);

            const mediaList = results.map((m, idx) => {
                const d = details[idx] || {};
                const statusText = (m.release_date && new Date(m.release_date) <= new Date()) ? 'Released' : 'Upcoming';
                const countries = (d.production_countries && d.production_countries.length)
                    ? d.production_countries.map(c => (c.iso_3166_1 || '').toLowerCase()).filter(Boolean).join(', ')
                    : (m.origin_country?.map(c => c.toLowerCase()).join(', ') || '-');
                return {...m, statusText, countries};
            });

            renderMovies(mediaList);
        } else {
            const mediaList = results.map(m => {
                const statusText = (m.first_air_date && new Date(m.first_air_date) <= new Date()) ? 'Aired' : 'Upcoming';
                const countries = m.origin_country?.map(c => c.toLowerCase()).join(', ') || '-';
                return {...m, statusText, countries};
            });

            renderMovies(mediaList);
        }

        renderPagination(page);
    }catch(err){ console.error("Fetch error:",err); document.getElementById("movieList").innerHTML="<p>Error loading data. Try again later.</p>";}
    finally{ document.getElementById('loader').style.display='none';}
}

function renderMovies(mediaList){
    const container=document.getElementById("movieList"); container.innerHTML="";
    mediaList.forEach(m=>{
        const img=m.poster_path?`https://image.tmdb.org/t/p/w300${m.poster_path}`:"https://netmoviestvshows.github.io/movie/images/no-poster-movie-tv.png";
        const title = mediaType === 'movie' ? m.title : m.name;
        const release = mediaType === 'movie'
            ? (m.release_date ? m.release_date.split('-')[0] : 'Unknown')
            : (m.first_air_date ? m.first_air_date.split('-')[0] : 'Unknown');
        const rating=m.vote_average != null ? m.vote_average.toFixed(1) : 'N/A';
        const safeTitle = String(title || '').replace(/\\/g,'\\\\').replace(/'/g,"\\'");
        container.innerHTML+=`
            <div class="movie" title="${title} (${release})">
              <div class="rating">‚≠ê ${rating}</div>
              <div class="media-type-icon">${mediaType==='movie'?'Movie':'TV'}</div>
                <img loading="lazy" src="${img}" alt="${title}" onclick="handleItemClick(event, ${m.id}, '${safeTitle}')">
                <div class="title">${title}</div>
                <div class="status">${m.statusText} : ${release}</div>
                <div class="country">${m.countries}</div>
            </div>`;
    });
}

function slugify(text){
    return String(text).toLowerCase().trim()
        .replace(/[^\u0000-\u007F\w\s-]/g, '')
        .replace(/[^a-z0-9\s-]/g,'')
        .replace(/\s+/g, '-')
        .replace(/-+/g,'-');
}

function handleItemClick(event, id, title){
    try{
        const slug = slugify(title || 'item');
        const newQuery = `?=${id}-${slug}`;
        history.pushState(null, '', window.location.pathname + newQuery);
    }catch(e){ console.warn('URL update failed', e); }
    try{ openModal(id); }catch(e){ console.error(e); }
}

function renderPagination(page){
    const pag=document.getElementById("pagination"); pag.innerHTML="";
    pag.innerHTML+=`<button onclick="goPage(1)" ${page===1?'disabled':''}>&laquo; First</button>
                    <button onclick="goPage(${page-1})" ${page===1?'disabled':''}>&lsaquo; Prev</button>`;
    const pages=[]; const total=maxPage;
    if(total>=1) pages.push(1);
    let start=Math.max(2,page-2); let end=Math.min(total-1,page+2);
    if(start>2) pages.push('...');
    for(let i=start;i<=end;i++) pages.push(i);
    if(end<total-1) pages.push('...');
    pages.push(total);
    const uniquePages=[...new Set(pages)];
    uniquePages.forEach(p=>{
        if(p==='...') pag.innerHTML+=`<span>‚Ä¶</span>`;
        else if(p===page) pag.innerHTML+=`<button class="active">${p}</button>`;
        else pag.innerHTML+=`<button onclick="goPage(${p})">${p}</button>`;
    });
    pag.innerHTML+=`<button onclick="goPage(${page+1})" ${page>=total?'disabled':''}>Next ‚Ä∫</button>
                     <button onclick="goPage(${total})" ${page>=total?'disabled':''}>Last ¬ª</button>`;
}

function goPage(p){if(p<1||p>maxPage)return; currentPage=p; loadMedia(p);} 
function changeMedia(){mediaType=document.getElementById('mediaType').value; updateCategoryDropdown(); updateGenreDropdown(); updateYearDropdown(); currentPage=1; loadMedia(currentPage);} 
function changeCategory(){mediaCategory=document.getElementById('mediaCategory').value; currentPage=1; loadMedia(currentPage);} 
function applyFilter(){selectedGenre=document.getElementById('genreFilter').value; selectedYear=document.getElementById('yearFilter').value; selectedSort=document.getElementById('sortFilter').value; currentPage=1; loadMedia(currentPage);} 

function doSearch(){
    searchQuery = document.getElementById('searchInput').value.trim();
    currentPage = 1;
    loadMedia(currentPage);
}

function clearSearch(){
    document.getElementById('searchInput').value = '';
    searchQuery = '';
    currentPage = 1;
    loadMedia(currentPage);
}

function onScoreChange(val){
    const v = parseFloat(val);
    minUserScore = v;
    document.getElementById('scoreLabel').textContent = v;
}

function onVotesChange(val){
    const v = parseInt(val,10);
    minUserVotes = v;
    document.getElementById('votesLabel').textContent = v;
}

function applyAllFilters(){
    selectedGenre = document.getElementById('genreFilter').value;
    selectedYear = document.getElementById('yearFilter').value;
    selectedSort = document.getElementById('sortFilter').value;
    searchQuery = document.getElementById('searchInput').value.trim();
    minUserScore = parseFloat(document.getElementById('scoreSlider').value) || 0;
    minUserVotes = parseInt(document.getElementById('votesSlider').value,10) || 0;
    currentPage = 1;
    loadMedia(currentPage);
}

function resetFilters(){
    document.getElementById('genreFilter').value = '';
    document.getElementById('yearFilter').value = '';
    document.getElementById('sortFilter').value = 'popularity.desc';
    document.getElementById('searchInput').value = '';
    document.getElementById('scoreSlider').value = 0;
    document.getElementById('votesSlider').value = 0;
    document.getElementById('scoreLabel').textContent = '0';
    document.getElementById('votesLabel').textContent = '0';

    selectedGenre = '';
    selectedYear = '';
    selectedSort = 'popularity.desc';
    searchQuery = '';
    minUserScore = 0;
    minUserVotes = 0;
    currentPage = 1;
    loadMedia(currentPage);
}

async function openModal(id) {
    const detailUrl = `https://api.themoviedb.org/3/${mediaType}/${id}?api_key=${API_KEY}&append_to_response=videos,credits,images`;
    try {
        const res = await fetch(detailUrl);
        const data = await res.json();

        // Backdrop & Poster
        const bigBackdropUrl = data.backdrop_path || data.poster_path ? `https://image.tmdb.org/t/p/w780${data.backdrop_path || data.poster_path}` : '';
        document.getElementById('modalBackdrop').style.backgroundImage = bigBackdropUrl ? `url(${bigBackdropUrl})` : '';
        document.getElementById('modalPoster').src = data.poster_path ? `https://image.tmdb.org/t/p/w300${data.poster_path}` : "https://netmoviestvshows.github.io/movie/images/no-poster-movie-tv.png";

        // Small blurred image behind the poster (uses a smaller size for performance)
        const smallBackdropPath = data.backdrop_path || data.poster_path || '';
        const smallBackdropUrl = smallBackdropPath ? `https://image.tmdb.org/t/p/w300${smallBackdropPath}` : '';
        const posterImageEl = document.getElementById('modalBackdropImage');
        if (posterImageEl) {
            posterImageEl.src = smallBackdropUrl ? smallBackdropUrl : '';
            posterImageEl.style.display = smallBackdropUrl ? 'block' : 'none';
            posterImageEl.alt = smallBackdropUrl ? (mediaType === 'movie' ? data.title : data.name) : '';
            posterImageEl.loading = 'lazy';
            posterImageEl.decoding = 'async';
        }

        // Prepare backdrop gallery (images.backdrops) and wire click on the small backdrop
        const backdropsList = (data.images && data.images.backdrops) ? data.images.backdrops : [];
        const backdropGallery = backdropsList.map(b => ({
            original: b.file_path ? `https://image.tmdb.org/t/p/w1280${b.file_path}` : '',
            // prefer w1280 for backdrop downloads (user requested 1280px)
            download: b.file_path ? `https://image.tmdb.org/t/p/w1280${b.file_path}` : '',
            medium: b.file_path ? `https://image.tmdb.org/t/p/w500${b.file_path}` : '',
            thumb: b.file_path ? `https://image.tmdb.org/t/p/w300${b.file_path}` : ''
        })).filter(x => x.original || x.medium || x.thumb || x.download);
        if (posterImageEl) {
            if (backdropGallery.length) {
                posterImageEl.style.cursor = 'zoom-in';
                posterImageEl.onclick = () => {
                    // set current gallery to backdrops and open grid gallery
                    window._currentGallery = backdropGallery;
                    window._currentGalleryType = 'backdrops';
                    window._currentGalleryIndex = 0;
                    openGallery(0);
                };
            } else {
                posterImageEl.style.cursor = 'default';
                posterImageEl.onclick = null;
            }
        }

        // Judul
        document.getElementById('modalTitle').textContent = mediaType === 'movie' ? data.title : data.name;
        try {
            const md = document.getElementById('modalDetails');
            if (md) {
                md.setAttribute('data-media-id', String(id));
                md.setAttribute('data-media-type', mediaType);
            }
        } catch(e) { /* ignore */ }

        // Prepare poster gallery (images.posters)
        const postersList = (data.images && data.images.posters) ? data.images.posters : [];
        // map to full urls (use original for main view, w500 for small)
        const postersGallery = postersList.map(p => ({
            original: p.file_path ? `https://image.tmdb.org/t/p/w1280${p.file_path}` : '',
            download: p.file_path ? `https://image.tmdb.org/t/p/w780${p.file_path}` : '',
            medium: p.file_path ? `https://image.tmdb.org/t/p/w500${p.file_path}` : '',
            thumb: p.file_path ? `https://image.tmdb.org/t/p/w300${p.file_path}` : ''
        })).filter(x => x.original || x.medium || x.thumb || x.download);
        // initialize current gallery to posters by default
        window._currentGallery = postersGallery;
        window._currentGalleryIndex = 0;
        // mark this as poster gallery
        window._currentGalleryType = 'posters';
        // wire poster click to open gallery if we have images
        const modalPosterEl = document.getElementById('modalPoster');
        if (modalPosterEl) {
            if (postersGallery && postersGallery.length) {
                modalPosterEl.style.cursor = 'zoom-in';
                // ensure clicking the poster restores the posters gallery (in case a backdrop gallery was opened earlier)
                modalPosterEl.onclick = () => {
                    window._currentGallery = postersGallery;
                    window._currentGalleryType = 'posters';
                    window._currentGalleryIndex = 0;
                    openGallery(0);
                };
            } else {
                modalPosterEl.style.cursor = 'default';
                modalPosterEl.onclick = null;
            }
        }

        // === META DENGAN DIV TERPISAH ===
const metaContainer = document.getElementById('modalMeta');
metaContainer.innerHTML = '';

const addMeta = (label, value) => {
    if (!value || value === 'N/A') value = '‚Äî';
    const div = document.createElement('div');
    div.className = 'meta-item';
    div.innerHTML = `
        <span class="meta-label">${label}</span>
        <span class="meta-value">${value}</span>
    `;
    metaContainer.appendChild(div);
};

// Rating
const avg = data.vote_average != null ? data.vote_average.toFixed(1) : 'N/A';
const count = data.vote_count != null ? data.vote_count : '0';
addMeta(`ID ${mediaType}: `, id);
addMeta('Rating : ', `‚≠ê ${avg} / ${count} votes`);

// Genres
addMeta('Genre : ', data.genres?.map(g => g.name).join(', ') || '‚Äî');

// Director / Created By
const directorLabel = mediaType === 'movie' ? 'Director : ' : 'Created By : ';
let directorValue = '‚Äî';
if (mediaType === 'movie') {
    directorValue = data.credits?.crew?.find(c => c.job === 'Director')?.name || '‚Äî';
} else {
    directorValue = data.created_by?.length
        ? data.created_by.map(c => c.name).join(', ')
        : (data.credits?.crew?.filter(c => c.job === 'Creator').map(c => c.name).join(', ') || '‚Äî');
}
addMeta(directorLabel, directorValue);

// Country
addMeta(
    'Country : ',
    data.production_countries?.map(c => c.name).join(', ')
    || data.origin_country?.join(', ')
    || '‚Äî'
);

// Language
addMeta(
    'Language : ',
    data.spoken_languages?.map(l => l.english_name).join(', ') || '‚Äî'
);

// Runtime / Seasons
if (mediaType === 'movie') {
    addMeta('Duration : ', data.runtime ? `${data.runtime} min` : '‚Äî');
} else {
    addMeta('Seasons : ', data.number_of_seasons || '‚Äî');
}

// Release date
const date = mediaType === 'movie' ? data.release_date : data.first_air_date;
const formatDateLong = d => {
    if (!d) return '‚Äî';
    const [y,m,day] = d.split('-');
    const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
    return `${months[parseInt(m)-1]} ${parseInt(day)}, ${y}`;
};
addMeta('Released : ', formatDateLong(date));

// Production
addMeta(
    'Production : ',
    data.production_companies?.map(p => p.name).join(', ') || '‚Äî'
);

// === CAST TERPISAH ===
const castContainer = document.getElementById('modalMeta-cast');
castContainer.innerHTML = '';

const castList = data.credits?.cast?.slice(0, 10) || [];

if (castList.length) {
    castList.forEach(c => {
        const div = document.createElement('div');
        div.className = 'cast-item';
        div.innerHTML = `
            
            <span class="cast-name meta-label">${c.name}</span>
            ${c.character ? `<span class="cast-role meta-value"><span class="as">as </span> ${c.character}</span>` : ''}
        `;
        castContainer.appendChild(div);
    });
} else {
    castContainer.innerHTML = '<div class="cast-item">‚Äî</div>';
}

        // Overview
        document.getElementById('modalOverview').textContent = data.overview || 'No overview available.';

        // Trailer
        const trailerDiv = document.getElementById('modalTrailer');
        trailerDiv.innerHTML = '';
        const trailer = data.videos?.results?.find(v => v.type === 'Trailer' && v.site === 'YouTube');
        if (trailer) {
            trailerDiv.innerHTML = `
                <h3 style="margin:20px 0 10px;">Trailer</h3>
                <iframe src="https://www.youtube.com/embed/${trailer.key}" 
                        allowfullscreen allow="autoplay; encrypted-media"></iframe>`;
        }

        document.getElementById('modal').style.display = 'block';
        // Populate AI suggestion chips for keyword & tone
        try{ populateAISuggestions(data); }catch(e){ console.warn('populateAISuggestions failed', e); }
        // if user opted to use AI suggestions automatically, fetch from server
        try{ const useAI = (document.getElementById('useAISuggest')||{}).checked; if(useAI) fetchAISuggestions(data); }catch(e){/* ignore */}
    } catch (err) {
        console.error("Fetch detail error:", err);
    }
}

// Build and render keyword + tone suggestions based on media detail
function populateAISuggestions(detail){
    const kwContainer = document.getElementById('aiKeywordSuggestions');
    const toneContainer = document.getElementById('aiToneSuggestions');
    if(!kwContainer || !toneContainer) return;
    kwContainer.innerHTML = '';
    toneContainer.innerHTML = '';

    const title = (detail.title || detail.name || '').trim();
    const genres = (detail.genres||[]).map(g=>g.name).filter(Boolean);
    const overview = (detail.overview||'').trim();
    const cast = (detail.credits && detail.credits.cast)? detail.credits.cast.map(c=>c.name).filter(Boolean) : [];

    const suggestions = new Set();
    if(title) suggestions.add(title);
    if(title && genres[0]) suggestions.add(`${title} ${genres[0]}`);
    if(genres[0]) suggestions.add(`${genres[0]} highlights`);
    if(cast[0]) suggestions.add(`${cast[0]} scene`);
    if(overview){
        // take first 3 words from overview as short hook
        const hook = overview.split(/\s+/).slice(0,4).join(' ');
        if(hook) suggestions.add(`${hook}...`);
    }
    suggestions.add('official trailer');
    suggestions.add('best moment');
    // Turn set into array and limit
    const kwList = Array.from(suggestions).slice(0,8);

    kwList.forEach(k=>{
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = k;
        btn.className = 'ai-suggestion-chip';
        btn.style.cssText = 'background:#122025;color:#fff;border:1px solid #254; padding:6px 8px;border-radius:6px;cursor:pointer; font-size:13px;';
        btn.onclick = ()=>{ document.getElementById('aiPrimaryKeyword').value = k; highlightSelectedChip(kwContainer, btn); };
        kwContainer.appendChild(btn);
    });

    // tone suggestions: map common genres to tones
    const toneMap = {
        'Action':'energetic','Adventure':'energetic','Comedy':'humorous','Drama':'dramatic','Horror':'suspenseful',
        'Romance':'emotional','Documentary':'informative','Fantasy':'epic','Science Fiction':'mysterious','Thriller':'urgent'
    };
    const toneSet = new Set();
    // prefer genre-derived tones
    genres.forEach(g=>{ if(toneMap[g]) toneSet.add(toneMap[g]); });
    // fallback tones
    ['energetic','dramatic','suspenseful','humorous','emotional','neutral'].forEach(t=>toneSet.add(t));

    Array.from(toneSet).slice(0,6).forEach(t=>{
        const b = document.createElement('button'); b.type='button'; b.textContent = t; b.className='ai-suggestion-chip';
        b.style.cssText='background:#122025;color:#fff;border:1px solid #254;padding:6px 8px;border-radius:6px;cursor:pointer;font-size:13px;';
        b.onclick = ()=>{ document.getElementById('aiTone').value = t; highlightSelectedChip(toneContainer, b); };
        toneContainer.appendChild(b);
    });

    // set placeholders to first suggestion
    if(kwList.length) document.getElementById('aiPrimaryKeyword').placeholder = kwList[0];
    const firstTone = toneContainer.querySelector('button');
    if(firstTone) document.getElementById('aiTone').placeholder = firstTone.textContent;
}

function highlightSelectedChip(container, btn){
    try{ Array.from(container.querySelectorAll('button')).forEach(b=>{ b.style.outline='none'; b.style.boxShadow='none'; b.style.opacity='1'; });
        btn.style.boxShadow='0 0 0 2px rgba(160,220,180,0.12)';
    }catch(e){}
}

// Fetch server-side AI suggestions and render chips (uses /ai/suggest)
async function fetchAISuggestions(detail){
    const kwContainer = document.getElementById('aiKeywordSuggestions');
    const toneContainer = document.getElementById('aiToneSuggestions');
    if(!kwContainer || !toneContainer) return;
    // show loading state
    const fetchBtn = document.getElementById('fetchAISuggestBtn');
    const oldTxt = fetchBtn ? fetchBtn.textContent : null;
    if(fetchBtn){ fetchBtn.disabled=true; fetchBtn.textContent='Loading...'; }

    try{
        const prov = (document.getElementById('aiProviderSelect')||{}).value || undefined;
        const model = (document.getElementById('aiModelSelect')||{}).value || undefined;
        const payload = { id: detail.id || detail.movie_id || detail.id, media_type: (detail.media_type||'movie'), provider: prov, model: model };
        const resp = await fetch(`${API_BASE}/ai/suggest`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        if(!resp.ok){ const err = await resp.json().catch(()=>({detail:resp.statusText})); throw new Error(err.detail||resp.statusText); }
        const data = await resp.json();
        // clear existing
        kwContainer.innerHTML = '';
        toneContainer.innerHTML = '';
        (data.keywords || []).slice(0,8).forEach(k=>{
            const btn = document.createElement('button'); btn.type='button'; btn.textContent = k; btn.className='ai-suggestion-chip';
            btn.style.cssText = 'background:#0f2622;color:#fff;border:1px solid #254;padding:6px 8px;border-radius:6px;cursor:pointer; font-size:13px;';
            btn.onclick = ()=>{ document.getElementById('aiPrimaryKeyword').value = k; highlightSelectedChip(kwContainer, btn); };
            kwContainer.appendChild(btn);
        });
        (data.tones || []).slice(0,6).forEach(t=>{
            const btn = document.createElement('button'); btn.type='button'; btn.textContent = t; btn.className='ai-suggestion-chip';
            btn.style.cssText = 'background:#0f2622;color:#fff;border:1px solid #254;padding:6px 8px;border-radius:6px;cursor:pointer; font-size:13px;';
            btn.onclick = ()=>{ document.getElementById('aiTone').value = t; highlightSelectedChip(toneContainer, btn); };
            toneContainer.appendChild(btn);
        });
        // set placeholders
        if((data.keywords||[]).length) document.getElementById('aiPrimaryKeyword').placeholder = (data.keywords||[])[0];
        if((data.tones||[]).length) document.getElementById('aiTone').placeholder = (data.tones||[])[0];
    }catch(e){ console.error('AI suggest failed', e); alert('AI suggestions failed: '+e.message); }
    finally{ if(fetchBtn){ fetchBtn.disabled=false; fetchBtn.textContent = oldTxt; } }
}

// wire manual fetch button
try{ const b = document.getElementById('fetchAISuggestBtn'); if(b) b.addEventListener('click', ()=>{
    try{ const md = document.getElementById('modalDetails'); if(!md) return alert('Modal not ready'); const id = parseInt(md.getAttribute('data-media-id'),10); const media_type = md.getAttribute('data-media-type') || mediaType; fetchAISuggestions({id:id, media_type: media_type}); }catch(e){console.warn(e);} }); }catch(e){}

function closeModal() {
    document.getElementById('modal').style.display = 'none';
    // remove media id/type markers from modalDetails
    try {
        const md = document.getElementById('modalDetails');
        if (md) { md.removeAttribute('data-media-id'); md.removeAttribute('data-media-type'); }
    } catch(e) { /* ignore */ }
    // also close gallery overlay if open
    try { closeGallery(); } catch(e) { /* ignore */ }
    // clear small backdrop image to free memory
    try {
        const b = document.getElementById('modalBackdropImage');
        if (b) { b.src = ''; b.style.display = 'none'; }
    } catch(e) { /* ignore */ }
}

// --- Gallery functions ---
function openGallery(startIndex = 0) {
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    window._currentGalleryIndex = startIndex || 0;
    const overlay = document.getElementById('galleryOverlay');
    const gridPosters = document.getElementById('galleryGrid');
    const gridBackdrops = document.getElementById('galleryGridBackdrop');
    const galleryType = window._currentGalleryType || 'posters';
    overlay.style.display = 'flex';

    // choose which grid to use and show/hide appropriately
    let grid;
    if (galleryType === 'backdrops') {
        if (gridPosters) { gridPosters.style.display = 'none'; gridPosters.innerHTML = ''; }
        if (gridBackdrops) { gridBackdrops.style.display = 'grid'; gridBackdrops.innerHTML = ''; }
        grid = gridBackdrops || gridPosters;
    } else {
        if (gridBackdrops) { gridBackdrops.style.display = 'none'; gridBackdrops.innerHTML = ''; }
        if (gridPosters) { gridPosters.style.display = 'grid'; gridPosters.innerHTML = ''; }
        grid = gridPosters || gridBackdrops;
    }

    // populate chosen grid with lazy-loading (use data-src + IntersectionObserver)
    const placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
    gallery.forEach((g, i) => {
        const card = document.createElement('div');
        // use distinct card class for backdrops so CSS can target it separately
        card.className = (galleryType === 'backdrops') ? 'gallery-backdrop-card' : 'gallery-card';
        const img = document.createElement('img');
        const realUrl = g.thumb || g.medium || g.original || '';
        img.dataset.src = realUrl;
        img.src = placeholder;
        img.alt = `${galleryType === 'backdrops' ? 'Backdrop' : 'Poster'} ${i+1}`;
        img.loading = 'lazy';
        img.decoding = 'async';
        img.style.cursor = realUrl ? 'zoom-in' : 'default';

        // clicking image still opens high-res in new tab (zoom). Keep behavior.
        img.onclick = () => {
            const openUrl = g.original || g.medium || g.thumb || '';
            if (openUrl) window.open(openUrl, '_blank');
        };

        // determine download URL (prefer explicit 'download' w780, fallback to original/medium)
        const downloadUrl = g.download || g.original || g.medium || g.thumb || '';

        // download button: direct download via fetch (to avoid opening new tab)
        const dlBtn = document.createElement('button');
        dlBtn.className = 'gallery-download-btn';
        dlBtn.type = 'button';
        // show correct hint: backdrops download at w1280, posters at w780
        dlBtn.title = (galleryType === 'backdrops') ? 'Download high-res (w1280)' : 'Download high-res (w780)';
        dlBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="32" d="M12 21c-4.97 0 -9 -4.03 -9 -9c0 -4.97 4.03 -9 9 -9"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.6s" values="32;0"/></path><path stroke-dasharray="2 4" stroke-dashoffset="6" d="M12 3c4.97 0 9 4.03 9 9c0 4.97 -4.03 9 -9 9" opacity="0"><set fill="freeze" attributeName="opacity" begin="0.45s" to="1"/><animateTransform fill="freeze" attributeName="transform" begin="0.45s" dur="0.6s" type="rotate" values="-180 12 12;0 12 12"/><animate attributeName="stroke-dashoffset" begin="0.85s" dur="0.6s" repeatCount="indefinite" to="0"/></path><path stroke-dasharray="10" stroke-dashoffset="10" d="M12 8v7.5"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.85s" dur="0.2s" to="0"/></path><path stroke-dasharray="8" stroke-dashoffset="8" d="M12 15.5l3.5 -3.5M12 15.5l-3.5 -3.5"><animate fill="freeze" attributeName="stroke-dashoffset" begin="1.05s" dur="0.2s" to="0"/></path></g></svg>`;
        dlBtn.style.cursor = downloadUrl ? 'pointer' : 'default';
        dlBtn.onclick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (!downloadUrl) return;
            const baseTitle = (document.getElementById('modalTitle') && document.getElementById('modalTitle').textContent) ? document.getElementById('modalTitle').textContent : '';
            const suffix = (galleryType === 'backdrops') ? 'backdrop' : 'poster';
            downloadHighRes(downloadUrl, baseTitle, suffix);
        };

        const meta = document.createElement('div');
        meta.className = 'card-meta';
        meta.textContent = `${galleryType === 'backdrops' ? 'Backdrop' : 'Poster'} ${i+1}`;
        card.appendChild(img);
        card.appendChild(dlBtn);
        card.appendChild(meta);
        if (grid) grid.appendChild(card);
    });

    // Setup IntersectionObserver to lazy-load images inside the gallery
    try {
        if (window._galleryObserver) { try { window._galleryObserver.disconnect(); } catch(e){} }
        const rootEl = document.getElementById('galleryInner');
        const imgs = (grid) ? grid.querySelectorAll('img[data-src]') : [];
        const obs = new IntersectionObserver((entries, observer) => {
            entries.forEach(ent => {
                if (ent.isIntersecting) {
                    const el = ent.target;
                    if (el.dataset && el.dataset.src) {
                        el.src = el.dataset.src;
                        el.removeAttribute('data-src');
                    }
                    observer.unobserve(el);
                }
            });
        }, { root: rootEl, rootMargin: '200px', threshold: 0.01 });
        imgs.forEach(iimg => obs.observe(iimg));
        window._galleryObserver = obs;
    } catch(e) { console.warn('gallery lazy observer failed', e); }
}

function closeGallery() {
    const overlay = document.getElementById('galleryOverlay');
    if (!overlay) return;
    overlay.style.display = 'none';
    // clear any grids
    try { const g1 = document.getElementById('galleryGrid'); if (g1) g1.innerHTML = ''; } catch(e){}
    try { const g2 = document.getElementById('galleryGridBackdrop'); if (g2) g2.innerHTML = ''; } catch(e){}
    // disconnect lazy loader observer
    try { if (window._galleryObserver) { window._galleryObserver.disconnect(); window._galleryObserver = null; } } catch(e) {}
}

async function downloadHighRes(url, baseTitle, suffix) {
    // maintain counts in-session to avoid duplicate filenames
    window._downloadNameCounts = window._downloadNameCounts || {};
    const base = (typeof baseTitle === 'string' && baseTitle.trim()) ? slugify(baseTitle.trim()) : '';
    const safeSuggested = base ? `${base}_${suffix || 'image'}` : (suffix || 'image');

    // Force extension to jpg for consistency
    const ext = 'jpg';

    // compute unique filename within this session
    const key = `${safeSuggested}.${ext}`;
    const count = window._downloadNameCounts[key] ? window._downloadNameCounts[key] + 1 : 1;
    window._downloadNameCounts[key] = count;
    const filename = count === 1 ? `${safeSuggested}.${ext}` : `${safeSuggested}_${count}.${ext}`;

    try {
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) throw new Error('Network response was not ok');
        const blob = await res.blob();
        const a = document.createElement('a');
        const objectUrl = URL.createObjectURL(blob);
        a.href = objectUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(objectUrl), 1000);
    } catch (err) {
        console.error('Download failed', err);
        // fallback: open in new tab so user can save manually
        try { window.open(url, '_blank'); } catch(e){}
    }
}

function updateGalleryImage() {
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    const idx = Math.max(0, Math.min(window._currentGalleryIndex || 0, gallery.length-1));
    window._currentGalleryIndex = idx;
    const img = document.getElementById('galleryImage');
    if (img) {
        img.src = gallery[idx].original || gallery[idx].medium || gallery[idx].thumb || '';
    }
    // update thumbs active
    const thumbs = document.querySelectorAll('.gallery-thumb');
    thumbs.forEach((t, i) => t.classList.toggle('active', i===idx));
}

function galleryPrev(){
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    window._currentGalleryIndex = (window._currentGalleryIndex - 1 + gallery.length) % gallery.length;
    updateGalleryImage();
}

function galleryNext(){
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    window._currentGalleryIndex = (window._currentGalleryIndex + 1) % gallery.length;
    updateGalleryImage();
}

function closeModalIfOutside(event) {
    if (event.target === document.getElementById('modal')) {
        closeModal();
    }
}

function openHelp(){
    document.getElementById('helpModal').style.display = 'block';
}

function closeHelp(){
    document.getElementById('helpModal').style.display = 'none';
}

// Parse querystring on load and open modal if pattern matches ?=id-slug
function parseQueryForMedia(){
    try{
        const q = window.location.search || '';
        const m = q.match(/^\?=(\d+)(?:-([a-z0-9-]+))?/i);
        if(m){
            const id = Number(m[1]);
            if(!isNaN(id)) openModal(id);
        }
    }catch(e){ console.warn('parseQueryForMedia failed', e); }
}

// Handle browser navigation (back/forward).
window.addEventListener('popstate', ()=>{
    try{
        const q = window.location.search || '';
        const m = q.match(/^\?=(\d+)(?:-([a-z0-9-]+))?/i);
        if(m){
            const id = Number(m[1]);
            if(!isNaN(id)) { openModal(id); return; }
        }
    }catch(e){ console.warn('popstate handler failed', e); }
    // no valid id in URL -> close modal
    try{ closeModal(); }catch(e){}
});

window.addEventListener('DOMContentLoaded', ()=>{
    parseQueryForMedia();
    // fetch available Gemini models and populate selector
    (async function(){
        try{
            const res = await fetch(`${API_BASE}/ai/list-models`);
            if(!res.ok) return;
            const j = await res.json();
            const models = j.models || [];
            // models may be an array or an object with _page
            let arr = models;
            if(Array.isArray(models)) arr = models;
            else if(models._page) arr = models._page;
            else if(models.page) arr = models.page;
            const sel = document.getElementById('aiModelSelect');
            if(!sel) return;
            // filter models that support generateContent or contain 'gemini' in name
            arr.forEach(m=>{
                try{
                    const name = m.name || m['name'];
                    const actions = m.supportedActions || m['supportedActions'] || [];
                    if(!name) return;
                    if(actions && actions.indexOf('generateContent')===-1 && name.indexOf('gemini')===-1) return;
                    const opt = document.createElement('option');
                    opt.value = name.replace(/^models\//,'');
                    opt.textContent = (m.displayName||name);
                    sel.appendChild(opt);
                }catch(e){ }
            });
        }catch(e){ /* ignore */ }
    })();
});

function onProviderChange(){
    const prov = (document.getElementById('aiProviderSelect')||{}).value;
    const modelSel = document.getElementById('aiModelSelect');
    if(prov === 'gemini'){
        if(modelSel) modelSel.style.display = 'inline-block';
    }else{
        if(modelSel) modelSel.style.display = 'none';
    }
}

// Title link: update URL to /trend/ without reloading
function goToTrend(event){
    try{
        if(event) event.preventDefault();
        history.pushState(null,'', '/trend/');
    }catch(e){ console.warn('goToTrend failed', e); }
}

// attach handler if element exists
try{
    const t = document.getElementById('titleLink');
    if(t) t.addEventListener('click', goToTrend);
}catch(e){}

// AI generation from modal
async function generateFromModal(platform){
    try{
        const md = document.getElementById('modalDetails');
        if(!md) return alert('Modal not ready');
        const id = parseInt(md.getAttribute('data-media-id'),10);
        const media_type = md.getAttribute('data-media-type') || mediaType;
        if(!id) return alert('No media id');

        const btnTik = document.getElementById('aiGenerateBtn-tiktok');
        const btnYt = document.getElementById('aiGenerateBtn-youtube');
        const resBox = document.getElementById('aiResult');
        const titleEl = document.getElementById('aiResultTitle');
        const descEl = document.getElementById('aiResultDescription');
        const tagsEl = document.getElementById('aiResultHashtags');

        // disable both buttons while generating
        if(btnTik) btnTik.disabled = true;
        if(btnYt) btnYt.disabled = true;
        if(platform === 'tiktok' && btnTik) btnTik.textContent = 'Generating...';
        if(platform === 'youtube' && btnYt) btnYt.textContent = 'Generating...';
        resBox.style.display = 'none';

        const provider = (document.getElementById('aiProviderSelect')||{}).value || undefined;
        let model = undefined;
        if(provider === 'gemini'){
            const msel = document.getElementById('aiModelSelect');
            if(msel && msel.value) model = msel.value;
        }
        const primary_keyword = (document.getElementById('aiPrimaryKeyword')||{}).value || undefined;
        const tone = (document.getElementById('aiTone')||{}).value || undefined;
        const variants = parseInt((document.getElementById('aiVariants')||{}).value || '1',10) || 1;

        const resp = await fetch(`${API_BASE}/ai/generate`, {
            method: 'POST', headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ id: id, media_type: media_type, platform: platform, provider: provider, model: model, primary_keyword: primary_keyword, tone: tone, variants: variants })
        });
        if(!resp.ok){
            const err = await resp.json().catch(()=>({detail:resp.statusText}));
            throw new Error(err.detail||resp.statusText);
        }
        const data = await resp.json();
        titleEl.textContent = data.title || '';
        descEl.textContent = data.description || '';
        tagsEl.textContent = (data.hashtags || []).join(' ');
        resBox.style.display = 'block';
    }catch(e){
        console.error('AI gen failed', e); alert('AI generation failed: '+e.message);
    }finally{
        const btnTik = document.getElementById('aiGenerateBtn-tiktok');
        const btnYt = document.getElementById('aiGenerateBtn-youtube');
        if(btnTik){ btnTik.disabled=false; btnTik.textContent='‚ú® Generate (TikTok)'; }
        if(btnYt){ btnYt.disabled=false; btnYt.textContent='‚ú® Generate (YouTube Shorts)'; }
    }
}
</script>

</body>
</html>


