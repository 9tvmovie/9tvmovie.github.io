<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Trending Movies & TV Shows</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style.css">
</head>
<body>

<h1><a id="titleLink" href="/trend/">üî• Trending Movies & TV Shows</a></h1>

<div class="controls">
    <select id="mediaType" onchange="changeMedia()">
        <option value="movie">Movie</option>
        <option value="tv">TV Show</option>
    </select>
    <select id="mediaCategory" onchange="changeCategory()"></select>
    <select id="genreFilter" onchange="applyFilter()"></select>
    <select id="yearFilter" onchange="applyFilter()"></select>
    <select id="sortFilter" onchange="applyFilter()">
        <option value="popularity.desc">Popularity Desc</option>
        <option value="popularity.asc">Popularity Asc</option>
        <option value="vote_average.desc">Rating Desc</option>
        <option value="vote_average.asc">Rating Asc</option>
        <option value="combined.desc">Combined: Popularity + Rating</option>
    </select>



<!-- Search -->
<div style="margin-bottom:14px; display:flex; gap:8px; align-items:baseline;flex-wrap: wrap;">
    <input id="searchInput" type="search" placeholder="Search movies or TV..." style="width: 260px; height: 30px; flex: 1; padding: 8px; border-radius: 6px; border: 1px solid #333; background: #111; color: #fff;" onkeydown="if(event.key==='Enter')doSearch()">
    <button onclick="doSearch()">Search</button>
    <button onclick="clearSearch()">Clear</button>
</div>

<!-- Filters: User Score & Minimum Votes -->
<div style="width: 100%;margin-bottom:14px; display:flex; gap:16px; align-items:center;">
    <div style="flex:1">
        <label for="scoreSlider" style="display:block; margin-bottom:6px;">User Score: (<span id="scoreLabel">0</span>-10)</label>
        <input id="scoreSlider" type="range" min="0" max="10" step="0.5" value="0" oninput="onScoreChange(this.value)">
    </div>
    <div style="width:260px;">
        <label for="votesSlider" style="display:block; margin-bottom:6px;">Min User Votes: <span id="votesLabel">0</span></label>
        <input id="votesSlider" type="range" min="0" max="1000" step="50" value="0" oninput="onVotesChange(this.value)">
    </div>
</div>
    
    <div style="margin-bottom:18px; display:flex; gap:8px;">
        <button onclick="applyAllFilters()" style="background:#4CAF50;">Apply Filters</button>
        <button onclick="resetFilters()" style="background:#c33;">Reset Filters</button>
        <button onclick="openHelp()" style="background:#0077ff;">Help</button>
    </div>
</div>
<div id="movieList" class="movie-grid"></div>
<div id="loader">‚è≥ Loading...</div>
<div id="pagination" class="pagination"></div>

<!-- Modal Structure -->
<div id="modal" onclick="closeModalIfOutside(event)">
    <div id="modalContent">
        <span id="closeModal" onclick="closeModal()">&times;</span>
        <div id="modalBackdrop"></div>
        <img id="modalPoster" src="" alt="">
        <img id="modalBackdropImage" src="" alt="" aria-hidden="true">
        <div id="modalDetails">
            <h2 id="modalTitle"></h2>
            <div class="modalMC">
            <div id="modalMeta"></div>
            <div id="modalMeta-cast"></div>
            </div>
            <p id="modalOverview"></p>

            <!-- GEMINI AI -->
             <div style="margin-top:16px;">
    <button onclick="generateAIContent()" style="background:#7c4dff;">
        ‚ú® Generate Title, Description & Hashtag
    </button>
</div>

<div id="aiResult" style="margin-top:14px; display:none;">
    <h3>AI Content</h3>
    <div><strong>Title:</strong> <span id="aiTitle"></span></div>
    <div><strong>Description:</strong>
        <p id="aiDescription"></p>
    </div>
    <div><strong>Hashtags:</strong>
        <p id="aiHashtags"></p>
    </div>
</div>
            <!-- END GEMINI AI -->
            <div id="modalTrailer"></div>
            <!-- Gallery overlay (hidden until opened) -->
            <div id="galleryOverlay" aria-hidden="true">
                <div id="galleryInner">
                    <button id="galleryClose" onclick="closeGallery()">&times;</button>
                    <div id="galleryGrid" role="list"></div>
                    <div id="galleryGridBackdrop" role="list" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Help Modal -->
<div id="helpModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:2000; overflow:auto;">
    <div style="max-width:900px; margin:3% auto; background:#0f1113; color:#fff; padding:20px; border-radius:8px; box-shadow:0 6px 30px rgba(0,0,0,0.7);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h2 style="margin:0;">Bantuan ‚Äî Cara Menggunakan</h2>
            <button onclick="closeHelp()" style="background:transparent;border:none;color:#fff;font-size:28px;cursor:pointer">&times;</button>
        </div>

        <div style="line-height:1.5; font-size:14px; color:#ddd;">
            <p>Halaman ini menampilkan daftar film dan acara TV trending dari TMDB. Berikut panduan fitur dan langkah penggunaan:</p>

            <h3 style="margin-top:8px;color: #1595e3;">1. Pilih Tipe Media</h3>
            <p>Gunakan dropdown <strong>Movie</strong> atau <strong>TV Show</strong> untuk berpindah antara daftar film dan acara TV.</p>

            <h3 style="color: #1595e3;">2. Kategori</h3>
            <p>Pilih kategori (mis. Popular, Now Playing, Upcoming, Top Rated) untuk melihat subset yang sesuai.</p>

            <h3 style="color: #1595e3;">3. Filter Genre & Tahun</h3>
            <p>Pilih genre dan tahun rilis/penayangan untuk mempersempit hasil.</p>

            <h3 style="color: #1595e3;">4. Pencarian</h3>
            <p>Ketik kata kunci pada kotak pencarian lalu tekan <strong>Enter</strong> atau klik <strong>Search</strong>. Untuk mengembalikan daftar default klik <strong>Clear</strong>.</p>

            <h3 style="color: #1595e3;">5. Sort / Urutkan</h3>
            <p>Gunakan dropdown <strong>Sort</strong> untuk mengurutkan berdasarkan popularitas, rating, atau opsi <strong>Combined</strong> (gabungan Popularity + Rating).</p>
            <p><em>Combined</em> menggunakan perhitungan internal: <code>score = popularity + (vote_average √ó 10)</code>. Pilih <code>Combined: ...</code> untuk hasil yang menyeimbangkan popularitas dan rating.</p>

            <h3 style="color: #1595e3;">6. User Score & Minimum Votes</h3>
            <p>Gunakan slider <strong style="color:#2c9dc1">User Score</strong> (0‚Äì10) untuk memfilter hanya item dengan rating minimal yang Anda inginkan. Atur <strong>Minimum User Votes</strong> untuk hanya menampilkan item dengan jumlah suara minimal.</p>
            <p>Contoh: jika User Score = 5 ‚Üí hasil menampilkan item dengan rating 5‚Äì10. Jika User Score = 0 ‚Üí menampilkan 0‚Äì10 (seluruh range).</p>
            <p>Bagaimana mekanismenya di aplikasi (terjadi jika Anda set <strong style="color:#2c9dc1">"Minimum User Votes"</strong> ke 500): </p>
<p>Untuk mode Discover (ketika tidak sedang melakukan pencarian): </p>
<li>Aplikasi menambahkan parameter query ke TMDB: vote_count.gte=500.</li>
<li>Filter dilakukan server-side oleh TMDB ‚Üí hasil yang dikembalikan sudah memenuhi ambang 500 suara.</li>
<li>Keuntungan: hasil konsisten, sedikit sampel tidak relevan, tidak perlu memfilter lagi di klien.</li>
<p>Untuk mode Search (ketika ada kata kunci di kotak pencarian): </p>
<li>Aplikasi memakai endpoint search TMDB yang tidak menerima vote_count.gte. </li>
<li>Setelah menerima halaman hasil (biasanya 20 item), aplikasi memfilter secara lokal: hanya memperlihatkan item dalam halaman yang punya vote_count >= 500. </li>
<li>Implikasi: jika banyak hasil pada halaman itu punya kurang dari 500 suara, daftar yang terlihat bisa berkurang drastis (atau kosong) ‚Äî aplikasi tidak otomatis mengambil halaman tambahan untuk memenuhi ambang itu. </li>
<p>Kualitas vs. Coverage: </p>
<li>Ambang tinggi (500) menaikkan kemungkinan rating lebih "stabil" dan mengurangi noise dari sedikit suara. </li>
<li>Tapi mem-bias-kan hasil terhadap film/acara populer dan lama; karya baru, indie, atau regional seringkali tersingkir walau berkualitas. </li>
<p>Pada search: karena filter hanya di-klien, Anda mungkin melihat sedikit atau nol hasil untuk kata kunci tertentu walau sebenarnya ada item relevan di halaman lain.</p>
<p>Performa/kuota: </p>
<li>Untuk Discover: server-side filter mengurangi jumlah item yang Anda tampilkan sehingga biasanya efisien. </li>
<li>Untuk Search: memfilter di-klien tidak menambah kuota, tapi bisa membuat UX terasa kosong; solusi lain membutuhkan permintaan tambahan (paging) atau logika berbeda. </li>



            <h3 style="color: #1595e3;">7. Apply / Reset</h3>
            <p>Setelah mengubah beberapa kontrol, klik <strong>Apply Filters</strong> untuk menerapkan semua sekaligus. Klik <strong>Reset Filters</strong> untuk mengembalikan pengaturan ke default.</p>

            <h3 style="color: #1595e3;">8. Melihat Detail</h3>
            <p>Klik poster sebuah item untuk membuka modal detail yang memuat:</p>
            <ul>
                <li>Rating (avg / jumlah suara)</li>
                <li>Genre</li>
                <li>Director (untuk movie) atau Created By (untuk TV)</li>
                <li>Production companies</li>
                <li>Cast (5 nama pertama)</li>
                <li>Country, Language, Duration/Seasons, Released</li>
                <li>Trailer (jika tersedia)</li>
            </ul>

            <h3 style="color: #1595e3;">9. Kolom Country</h3>
            <p>Di daftar, country menampilkan kode ISO (mis. <code>us</code>) bila tersedia. Detail modal menampilkan nama negara penuh.</p>

            <h3 style="color: #1595e3;">10. Catatan Performa & Kuota API</h3>
            <p>Daftar film meminta data detail per item untuk menampilkan beberapa field (mis. production_countries). Ini menambah jumlah request (¬±20 request per halaman) dan dapat memperlambat pemuatan serta menggunakan kuota TMDB lebih cepat. Jika Anda ingin performa lebih cepat, pilih salah satu opsi:</p>
            <ul>
                <li>Nonaktifkan pengambilan detail otomatis dan ambil detail hanya saat membuka modal.</li>
                <li>Gunakan caching di sisi klien atau server untuk menyimpan detail yang sudah pernah diambil.</li>
                <li>Gunakan lazy-load: ambil negara hanya saat item terlihat atau saat hover.</li>
            </ul>

            <h3 style="color: #1595e3;">11. Tips Penggunaan</h3>
            <ul>
                <li>Untuk cepat menemukan film populer berkualitas, gunakan <strong>Combined</strong> + atur Minimum User Votes tinggi (mis. 500).</li>
                <li>Jika hasil terlalu sedikit, turunkan Minimum User Votes atau User Score.</li>
                <li>Gunakan filter genre + tahun untuk menemukan film sesuai selera.</li>
            </ul>

            <p style="margin-top:12px; color:#ccc;">Jika Anda mau, saya bisa menambahkan: tombol toggle untuk mematikan detail-per-item (untuk performa), caching sederhana, atau bantuan tooltips singkat di kontrol.</p>
        </div>
    </div>
</div>

<script>
const API_KEY = "aa39650b8e660d5046678ac425688903";
let currentPage=1, maxPage=1, mediaType='movie', mediaCategory='popular';
let selectedGenre='', selectedYear='', selectedSort='popularity.desc';
let searchQuery = '';
let minUserScore = 0; // 0..10
let minUserVotes = 0; // minimum vote_count

const categories = {
    movie:[{value:'popular',text:'Popular'},{value:'now_playing',text:'Now Playing'},{value:'upcoming',text:'Upcoming'},{value:'top_rated',text:'Top Rated'}],
    tv:[{value:'popular',text:'Popular'},{value:'airing_today',text:'Airing Today'},{value:'on_the_air',text:'On TV'},{value:'top_rated',text:'Top Rated'}]
};

const movieGenres={28:"Action",12:"Adventure",16:"Animation",35:"Comedy",80:"Crime",99:"Documentary",18:"Drama",10751:"Family",14:"Fantasy",36:"History",27:"Horror",10402:"Music",9648:"Mystery",10749:"Romance",878:"Science Fiction",10770:"TV Movie",53:"Thriller",10752:"War",37:"Western"};
const tvGenres={10759:"Action & Adventure",16:"Animation",35:"Comedy",80:"Crime",99:"Documentary",18:"Drama",10751:"Family",10762:"Kids",9648:"Mystery",10763:"News",10764:"Reality",10765:"Sci-Fi & Fantasy",10766:"Soap",10767:"Talk",10768:"War & Politics",37:"Western"};

function updateCategoryDropdown(){
    const catSelect=document.getElementById('mediaCategory');
    catSelect.innerHTML='';
    categories[mediaType].forEach(cat=>{
        const opt=document.createElement('option');
        opt.value=cat.value; opt.text=cat.text;
        catSelect.appendChild(opt);
    });
    mediaCategory=catSelect.value;
}

function updateGenreDropdown(){
    const genreSelect=document.getElementById('genreFilter'); genreSelect.innerHTML='<option value="">All Genres</option>';
    const genres=mediaType==='movie'? movieGenres:tvGenres;
    Object.entries(genres).forEach(([id,name])=>{
        const opt=document.createElement('option'); opt.value=id; opt.text=name; genreSelect.appendChild(opt);
    });
    selectedGenre='';
}

function updateYearDropdown(){
    const yearSelect=document.getElementById('yearFilter'); yearSelect.innerHTML='<option value="">All Years</option>';
    const currentYear=(new Date()).getFullYear();
    for(let y=currentYear;y>=1950;y--){
        const opt=document.createElement('option'); opt.value=y; opt.text=y; yearSelect.appendChild(opt);
    }
    selectedYear='';
}

updateCategoryDropdown(); updateGenreDropdown(); updateYearDropdown(); loadMedia(currentPage);

async function loadMedia(page){
    document.getElementById('loader').style.display='block';
    let url="";
    const params=new URLSearchParams();
    if(selectedGenre) params.append('with_genres',selectedGenre);
    if(selectedYear){ if(mediaType==='movie') params.append('primary_release_year',selectedYear); else params.append('first_air_date_year',selectedYear);}
    if(selectedSort && !selectedSort.startsWith('combined')) params.append('sort_by',selectedSort);

    // Tambahkan filter rating & vote_count untuk discover endpoint
    // vote_average.gte = minUserScore, vote_average.lte = 10
    if (typeof minUserScore === 'number' && minUserScore > 0) {
        params.append('vote_average.gte', String(minUserScore));
    } else {
        // selalu pastikan batas atas 10 jika ingin konsisten
        // jika minUserScore == 0, kita tidak perlu menambahkan vote_average.gte
    }
    // Tambahkan upper-bound rating (selalu 10)
    params.append('vote_average.lte', '10');
    if (typeof minUserVotes === 'number' && minUserVotes > 0) {
        params.append('vote_count.gte', String(minUserVotes));
    }
    
    // Jika ada searchQuery -> gunakan endpoint search
    if (searchQuery) {
        url = `https://api.themoviedb.org/3/search/${mediaType}?api_key=${API_KEY}&query=${encodeURIComponent(searchQuery)}&page=${page}`;
    } else {
        // Tentukan endpoint (tanpa search)
        if(mediaType==='movie'){
            if(['popular','top_rated'].includes(mediaCategory) || selectedGenre || selectedYear){
                url=`https://api.themoviedb.org/3/discover/movie?api_key=${API_KEY}&page=${page}&sort_by=${mediaCategory==='top_rated'?'vote_average.desc':'popularity.desc'}`;
                url += '&'+params.toString();
            } else if(mediaCategory==='now_playing'){
                url=`https://api.themoviedb.org/3/movie/now_playing?api_key=${API_KEY}&page=${page}`;
            } else if(mediaCategory==='upcoming'){
                url=`https://api.themoviedb.org/3/movie/upcoming?api_key=${API_KEY}&page=${page}`;
            }
        } else {
            if(['popular','top_rated'].includes(mediaCategory) || selectedGenre || selectedYear){
                url=`https://api.themoviedb.org/3/discover/tv?api_key=${API_KEY}&page=${page}&sort_by=${mediaCategory==='top_rated'?'vote_average.desc':'popularity.desc'}`;
                url += '&'+params.toString();
            } else if(mediaCategory==='airing_today'){
                url=`https://api.themoviedb.org/3/tv/airing_today?api_key=${API_KEY}&page=${page}`;
            } else if(mediaCategory==='on_the_air'){
                url=`https://api.themoviedb.org/3/tv/on_the_air?api_key=${API_KEY}&page=${page}`;
            }
        }
    }

    try{
        const res=await fetch(url);
        const data=await res.json();
        maxPage=data.total_pages>500?500:data.total_pages;

        let results = data.results || [];

        // Jika memilih sort gabungan (combined), urutkan lokal berdasarkan popularity + vote_average*10
        if (selectedSort && selectedSort.startsWith('combined')) {
            const desc = selectedSort.endsWith('.desc');
            results.sort((a,b) => {
                const score = (item) => (item.popularity || 0) + ((item.vote_average || 0) * 10);
                const sa = score(a);
                const sb = score(b);
                return desc ? (sb - sa) : (sa - sb);
            });
        }

        // Jika search digunakan (atau sebagai safety), filter lokal berdasarkan slider User Score dan Minimum Votes
        const minScore = typeof minUserScore === 'number' ? minUserScore : 0;
        const minVotes = typeof minUserVotes === 'number' ? minUserVotes : 0;
        if (minScore > 0 || minVotes > 0) {
            results = results.filter(r => {
                const avg = r.vote_average != null ? r.vote_average : 0;
                const vc = r.vote_count != null ? r.vote_count : 0;
                return avg >= minScore && avg <= 10 && vc >= minVotes;
            });
        }

        // Untuk movie: list endpoint tidak selalu menyertakan production_countries.
        // Ambil detail setiap movie untuk mendapatkan production_countries agar bisa ditampilkan di list.
        if(mediaType === 'movie'){
            const detailPromises = results.map(r =>
                fetch(`https://api.themoviedb.org/3/movie/${r.id}?api_key=${API_KEY}`)
                    .then(res => res.json())
                    .catch(() => null)
            );
            const details = await Promise.all(detailPromises);

            const mediaList = results.map((m, idx) => {
                const d = details[idx] || {};
                const statusText = (m.release_date && new Date(m.release_date) <= new Date()) ? 'Released' : 'Upcoming';
                const countries = (d.production_countries && d.production_countries.length)
                    ? d.production_countries.map(c => (c.iso_3166_1 || '').toLowerCase()).filter(Boolean).join(', ')
                    : (m.origin_country?.map(c => c.toLowerCase()).join(', ') || '-');
                return {...m, statusText, countries};
            });

            renderMovies(mediaList);
        } else {
            const mediaList = results.map(m => {
                const statusText = (m.first_air_date && new Date(m.first_air_date) <= new Date()) ? 'Aired' : 'Upcoming';
                const countries = m.origin_country?.map(c => c.toLowerCase()).join(', ') || '-';
                return {...m, statusText, countries};
            });

            renderMovies(mediaList);
        }

        renderPagination(page);
    }catch(err){ console.error("Fetch error:",err); document.getElementById("movieList").innerHTML="<p>Error loading data. Try again later.</p>";}
    finally{ document.getElementById('loader').style.display='none';}
}

function renderMovies(mediaList){
    const container=document.getElementById("movieList"); container.innerHTML="";
    mediaList.forEach(m=>{
        const img=m.poster_path?`https://image.tmdb.org/t/p/w300${m.poster_path}`:"https://netmoviestvshows.github.io/movie/images/no-poster-movie-tv.png";
        const title = mediaType === 'movie' ? m.title : m.name;
        const release = mediaType === 'movie'
            ? (m.release_date ? m.release_date.split('-')[0] : 'Unknown')
            : (m.first_air_date ? m.first_air_date.split('-')[0] : 'Unknown');
        const rating=m.vote_average != null ? m.vote_average.toFixed(1) : 'N/A';
        const safeTitle = String(title || '').replace(/\\/g,'\\\\').replace(/'/g,"\\'");
        container.innerHTML+=`
            <div class="movie" title="${title} (${release})">
              <div class="rating">‚≠ê ${rating}</div>
              <div class="media-type-icon">${mediaType==='movie'?'Movie':'TV'}</div>
                <img loading="lazy" src="${img}" alt="${title}" onclick="handleItemClick(event, ${m.id}, '${safeTitle}')">
                <div class="title">${title}</div>
                <div class="status">${m.statusText} : ${release}</div>
                <div class="country">${m.countries}</div>
            </div>`;
    });
}

// Convert a title to a URL-friendly slug
function slugify(text){
    return String(text).toLowerCase().trim()
        .replace(/[^\u0000-\u007F\w\s-]/g, '')
        .replace(/[^a-z0-9\s-]/g,'')
        .replace(/\s+/g, '-')
        .replace(/-+/g,'-');
}

// Handle clicking an item: update URL with ?=id-slug-title and open modal
function handleItemClick(event, id, title){
    try{
        const slug = slugify(title || 'item');
        const newQuery = `?=${id}-${slug}`;
        // update URL without reloading
        history.pushState(null, '', window.location.pathname + newQuery);
    }catch(e){ console.warn('URL update failed', e); }
    // open modal (existing behaviour)
    try{ openModal(id); }catch(e){ console.error(e); }
}

function renderPagination(page){
    const pag=document.getElementById("pagination"); pag.innerHTML="";
    pag.innerHTML+=`<button onclick="goPage(1)" ${page===1?'disabled':''}>&laquo; First</button>
                    <button onclick="goPage(${page-1})" ${page===1?'disabled':''}>&lsaquo; Prev</button>`;
    const pages=[]; const total=maxPage;
    if(total>=1) pages.push(1);
    let start=Math.max(2,page-2); let end=Math.min(total-1,page+2);
    if(start>2) pages.push('...');
    for(let i=start;i<=end;i++) pages.push(i);
    if(end<total-1) pages.push('...');
    pages.push(total);
    const uniquePages=[...new Set(pages)];
    uniquePages.forEach(p=>{
        if(p==='...') pag.innerHTML+=`<span>‚Ä¶</span>`;
        else if(p===page) pag.innerHTML+=`<button class="active">${p}</button>`;
        else pag.innerHTML+=`<button onclick="goPage(${p})">${p}</button>`;
    });
    pag.innerHTML+=`<button onclick="goPage(${page+1})" ${page>=total?'disabled':''}>Next ‚Ä∫</button>
                     <button onclick="goPage(${total})" ${page>=total?'disabled':''}>Last ¬ª</button>`;
}

function goPage(p){if(p<1||p>maxPage)return; currentPage=p; loadMedia(p);}
function changeMedia(){mediaType=document.getElementById('mediaType').value; updateCategoryDropdown(); updateGenreDropdown(); updateYearDropdown(); currentPage=1; loadMedia(currentPage);}
function changeCategory(){mediaCategory=document.getElementById('mediaCategory').value; currentPage=1; loadMedia(currentPage);}
function applyFilter(){selectedGenre=document.getElementById('genreFilter').value; selectedYear=document.getElementById('yearFilter').value; selectedSort=document.getElementById('sortFilter').value; currentPage=1; loadMedia(currentPage);}

function doSearch(){
    searchQuery = document.getElementById('searchInput').value.trim();
    currentPage = 1;
    loadMedia(currentPage);
}

function clearSearch(){
    document.getElementById('searchInput').value = '';
    searchQuery = '';
    currentPage = 1;
    loadMedia(currentPage);
}

function onScoreChange(val){
    const v = parseFloat(val);
    minUserScore = v;
    document.getElementById('scoreLabel').textContent = v;
}

function onVotesChange(val){
    const v = parseInt(val,10);
    minUserVotes = v;
    document.getElementById('votesLabel').textContent = v;
}

function applyAllFilters(){
    // Read UI controls and apply as current filters, then reload
    selectedGenre = document.getElementById('genreFilter').value;
    selectedYear = document.getElementById('yearFilter').value;
    selectedSort = document.getElementById('sortFilter').value;
    searchQuery = document.getElementById('searchInput').value.trim();
    minUserScore = parseFloat(document.getElementById('scoreSlider').value) || 0;
    minUserVotes = parseInt(document.getElementById('votesSlider').value,10) || 0;
    currentPage = 1;
    loadMedia(currentPage);
}

function resetFilters(){
    // Reset UI controls to defaults
    document.getElementById('genreFilter').value = '';
    document.getElementById('yearFilter').value = '';
    document.getElementById('sortFilter').value = 'popularity.desc';
    document.getElementById('searchInput').value = '';
    document.getElementById('scoreSlider').value = 0;
    document.getElementById('votesSlider').value = 0;
    document.getElementById('scoreLabel').textContent = '0';
    document.getElementById('votesLabel').textContent = '0';

    // Reset state
    selectedGenre = '';
    selectedYear = '';
    selectedSort = 'popularity.desc';
    searchQuery = '';
    minUserScore = 0;
    minUserVotes = 0;
    currentPage = 1;
    loadMedia(currentPage);
}

// Modal Functions
async function openModal(id) {
    const detailUrl = `https://api.themoviedb.org/3/${mediaType}/${id}?api_key=${API_KEY}&append_to_response=videos,credits,images`;
    try {
        const res = await fetch(detailUrl);
        const data = await res.json();

        // Backdrop & Poster
        const bigBackdropUrl = data.backdrop_path || data.poster_path ? `https://image.tmdb.org/t/p/w780${data.backdrop_path || data.poster_path}` : '';
        document.getElementById('modalBackdrop').style.backgroundImage = bigBackdropUrl ? `url(${bigBackdropUrl})` : '';
        document.getElementById('modalPoster').src = data.poster_path ? `https://image.tmdb.org/t/p/w300${data.poster_path}` : "https://netmoviestvshows.github.io/movie/images/no-poster-movie-tv.png";

        // Small blurred image behind the poster (uses a smaller size for performance)
        const smallBackdropPath = data.backdrop_path || data.poster_path || '';
        const smallBackdropUrl = smallBackdropPath ? `https://image.tmdb.org/t/p/w300${smallBackdropPath}` : '';
        const posterImageEl = document.getElementById('modalBackdropImage');
        if (posterImageEl) {
            posterImageEl.src = smallBackdropUrl ? smallBackdropUrl : '';
            posterImageEl.style.display = smallBackdropUrl ? 'block' : 'none';
            posterImageEl.alt = smallBackdropUrl ? (mediaType === 'movie' ? data.title : data.name) : '';
            posterImageEl.loading = 'lazy';
            posterImageEl.decoding = 'async';
        }

        // Prepare backdrop gallery (images.backdrops) and wire click on the small backdrop
        const backdropsList = (data.images && data.images.backdrops) ? data.images.backdrops : [];
        const backdropGallery = backdropsList.map(b => ({
            original: b.file_path ? `https://image.tmdb.org/t/p/w1280${b.file_path}` : '',
            // prefer w1280 for backdrop downloads (user requested 1280px)
            download: b.file_path ? `https://image.tmdb.org/t/p/w1280${b.file_path}` : '',
            medium: b.file_path ? `https://image.tmdb.org/t/p/w500${b.file_path}` : '',
            thumb: b.file_path ? `https://image.tmdb.org/t/p/w300${b.file_path}` : ''
        })).filter(x => x.original || x.medium || x.thumb || x.download);
        if (posterImageEl) {
            if (backdropGallery.length) {
                posterImageEl.style.cursor = 'zoom-in';
                posterImageEl.onclick = () => {
                    // set current gallery to backdrops and open grid gallery
                    window._currentGallery = backdropGallery;
                    window._currentGalleryType = 'backdrops';
                    window._currentGalleryIndex = 0;
                    openGallery(0);
                };
            } else {
                posterImageEl.style.cursor = 'default';
                posterImageEl.onclick = null;
            }
        }

        // Judul
        document.getElementById('modalTitle').textContent = mediaType === 'movie' ? data.title : data.name;
        // mark modalDetails with current media id and type for easier reference
        try {
            const md = document.getElementById('modalDetails');
            if (md) {
                md.setAttribute('data-media-id', String(id));
                md.setAttribute('data-media-type', mediaType);
            }
        } catch(e) { /* ignore */ }

        // Prepare poster gallery (images.posters)
        const postersList = (data.images && data.images.posters) ? data.images.posters : [];
        // map to full urls (use original for main view, w500 for small)
        const postersGallery = postersList.map(p => ({
            original: p.file_path ? `https://image.tmdb.org/t/p/w1280${p.file_path}` : '',
            download: p.file_path ? `https://image.tmdb.org/t/p/w780${p.file_path}` : '',
            medium: p.file_path ? `https://image.tmdb.org/t/p/w500${p.file_path}` : '',
            thumb: p.file_path ? `https://image.tmdb.org/t/p/w300${p.file_path}` : ''
        })).filter(x => x.original || x.medium || x.thumb || x.download);
        // initialize current gallery to posters by default
        window._currentGallery = postersGallery;
        window._currentGalleryIndex = 0;
        // mark this as poster gallery
        window._currentGalleryType = 'posters';
        // wire poster click to open gallery if we have images
        const modalPosterEl = document.getElementById('modalPoster');
        if (modalPosterEl) {
            if (postersGallery && postersGallery.length) {
                modalPosterEl.style.cursor = 'zoom-in';
                // ensure clicking the poster restores the posters gallery (in case a backdrop gallery was opened earlier)
                modalPosterEl.onclick = () => {
                    window._currentGallery = postersGallery;
                    window._currentGalleryType = 'posters';
                    window._currentGalleryIndex = 0;
                    openGallery(0);
                };
            } else {
                modalPosterEl.style.cursor = 'default';
                modalPosterEl.onclick = null;
            }
        }

        // === META DENGAN DIV TERPISAH ===
const metaContainer = document.getElementById('modalMeta');
metaContainer.innerHTML = '';

const addMeta = (label, value) => {
    if (!value || value === 'N/A') value = '‚Äî';
    const div = document.createElement('div');
    div.className = 'meta-item';
    div.innerHTML = `
        <span class="meta-label">${label}</span>
        <span class="meta-value">${value}</span>
    `;
    metaContainer.appendChild(div);
};

// Rating
const avg = data.vote_average != null ? data.vote_average.toFixed(1) : 'N/A';
const count = data.vote_count != null ? data.vote_count : '0';
addMeta(`ID ${mediaType}: `, id);
addMeta('Rating : ', `‚≠ê ${avg} / ${count} votes`);

// Genres
addMeta('Genre : ', data.genres?.map(g => g.name).join(', ') || '‚Äî');

// Director / Created By
const directorLabel = mediaType === 'movie' ? 'Director : ' : 'Created By : ';
let directorValue = '‚Äî';
if (mediaType === 'movie') {
    directorValue = data.credits?.crew?.find(c => c.job === 'Director')?.name || '‚Äî';
} else {
    directorValue = data.created_by?.length
        ? data.created_by.map(c => c.name).join(', ')
        : (data.credits?.crew?.filter(c => c.job === 'Creator').map(c => c.name).join(', ') || '‚Äî');
}
addMeta(directorLabel, directorValue);

// Country
addMeta(
    'Country : ',
    data.production_countries?.map(c => c.name).join(', ')
    || data.origin_country?.join(', ')
    || '‚Äî'
);

// Language
addMeta(
    'Language : ',
    data.spoken_languages?.map(l => l.english_name).join(', ') || '‚Äî'
);

// Runtime / Seasons
if (mediaType === 'movie') {
    addMeta('Duration : ', data.runtime ? `${data.runtime} min` : '‚Äî');
} else {
    addMeta('Seasons : ', data.number_of_seasons || '‚Äî');
}

// Release date
const date = mediaType === 'movie' ? data.release_date : data.first_air_date;
const formatDateLong = d => {
    if (!d) return '‚Äî';
    const [y,m,day] = d.split('-');
    const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
    return `${months[parseInt(m)-1]} ${parseInt(day)}, ${y}`;
};
addMeta('Released : ', formatDateLong(date));

// Production
addMeta(
    'Production : ',
    data.production_companies?.map(p => p.name).join(', ') || '‚Äî'
);

// === CAST TERPISAH ===
const castContainer = document.getElementById('modalMeta-cast');
castContainer.innerHTML = '';

const castList = data.credits?.cast?.slice(0, 10) || [];

if (castList.length) {
    castList.forEach(c => {
        const div = document.createElement('div');
        div.className = 'cast-item';
        div.innerHTML = `
            
            <span class="cast-name meta-label">${c.name}</span>
            ${c.character ? `<span class="cast-role meta-value"><span class="as">as </span> ${c.character}</span>` : ''}
        `;
        castContainer.appendChild(div);
    });
} else {
    castContainer.innerHTML = '<div class="cast-item">‚Äî</div>';
}

        

        // Overview
        document.getElementById('modalOverview').textContent = data.overview || 'No overview available.';

        // Trailer
        const trailerDiv = document.getElementById('modalTrailer');
        trailerDiv.innerHTML = '';
        const trailer = data.videos?.results?.find(v => v.type === 'Trailer' && v.site === 'YouTube');
        if (trailer) {
            trailerDiv.innerHTML = `
                <h3 style="margin:20px 0 10px;">Trailer</h3>
                <iframe src="https://www.youtube.com/embed/${trailer.key}" 
                        allowfullscreen allow="autoplay; encrypted-media"></iframe>`;
        }

        document.getElementById('modal').style.display = 'block';
    } catch (err) {
        console.error("Fetch detail error:", err);
    }
}

function closeModal() {
    document.getElementById('modal').style.display = 'none';
    // remove media id/type markers from modalDetails
    try {
        const md = document.getElementById('modalDetails');
        if (md) { md.removeAttribute('data-media-id'); md.removeAttribute('data-media-type'); }
    } catch(e) { /* ignore */ }
    // also close gallery overlay if open
    try { closeGallery(); } catch(e) { /* ignore */ }
    // clear small backdrop image to free memory
    try {
        const b = document.getElementById('modalBackdropImage');
        if (b) { b.src = ''; b.style.display = 'none'; }
    } catch(e) { /* ignore */ }
}

// --- Gallery functions ---
function openGallery(startIndex = 0) {
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    window._currentGalleryIndex = startIndex || 0;
    const overlay = document.getElementById('galleryOverlay');
    const gridPosters = document.getElementById('galleryGrid');
    const gridBackdrops = document.getElementById('galleryGridBackdrop');
    const galleryType = window._currentGalleryType || 'posters';
    overlay.style.display = 'flex';

    // choose which grid to use and show/hide appropriately
    let grid;
    if (galleryType === 'backdrops') {
        if (gridPosters) { gridPosters.style.display = 'none'; gridPosters.innerHTML = ''; }
        if (gridBackdrops) { gridBackdrops.style.display = 'grid'; gridBackdrops.innerHTML = ''; }
        grid = gridBackdrops || gridPosters;
    } else {
        if (gridBackdrops) { gridBackdrops.style.display = 'none'; gridBackdrops.innerHTML = ''; }
        if (gridPosters) { gridPosters.style.display = 'grid'; gridPosters.innerHTML = ''; }
        grid = gridPosters || gridBackdrops;
    }

    // populate chosen grid with lazy-loading (use data-src + IntersectionObserver)
    const placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
    gallery.forEach((g, i) => {
        const card = document.createElement('div');
        // use distinct card class for backdrops so CSS can target it separately
        card.className = (galleryType === 'backdrops') ? 'gallery-backdrop-card' : 'gallery-card';
        const img = document.createElement('img');
        const realUrl = g.thumb || g.medium || g.original || '';
        img.dataset.src = realUrl;
        img.src = placeholder;
        img.alt = `${galleryType === 'backdrops' ? 'Backdrop' : 'Poster'} ${i+1}`;
        img.loading = 'lazy';
        img.decoding = 'async';
        img.style.cursor = realUrl ? 'zoom-in' : 'default';

        // clicking image still opens high-res in new tab (zoom). Keep behavior.
        img.onclick = () => {
            const openUrl = g.original || g.medium || g.thumb || '';
            if (openUrl) window.open(openUrl, '_blank');
        };

        // determine download URL (prefer explicit 'download' w780, fallback to original/medium)
        const downloadUrl = g.download || g.original || g.medium || g.thumb || '';

        // download button: direct download via fetch (to avoid opening new tab)
        const dlBtn = document.createElement('button');
        dlBtn.className = 'gallery-download-btn';
        dlBtn.type = 'button';
        // show correct hint: backdrops download at w1280, posters at w780
        dlBtn.title = (galleryType === 'backdrops') ? 'Download high-res (w1280)' : 'Download high-res (w780)';
        dlBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="32" d="M12 21c-4.97 0 -9 -4.03 -9 -9c0 -4.97 4.03 -9 9 -9"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.6s" values="32;0"/></path><path stroke-dasharray="2 4" stroke-dashoffset="6" d="M12 3c4.97 0 9 4.03 9 9c0 4.97 -4.03 9 -9 9" opacity="0"><set fill="freeze" attributeName="opacity" begin="0.45s" to="1"/><animateTransform fill="freeze" attributeName="transform" begin="0.45s" dur="0.6s" type="rotate" values="-180 12 12;0 12 12"/><animate attributeName="stroke-dashoffset" begin="0.85s" dur="0.6s" repeatCount="indefinite" to="0"/></path><path stroke-dasharray="10" stroke-dashoffset="10" d="M12 8v7.5"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.85s" dur="0.2s" to="0"/></path><path stroke-dasharray="8" stroke-dashoffset="8" d="M12 15.5l3.5 -3.5M12 15.5l-3.5 -3.5"><animate fill="freeze" attributeName="stroke-dashoffset" begin="1.05s" dur="0.2s" to="0"/></path></g></svg>`;
        dlBtn.style.cursor = downloadUrl ? 'pointer' : 'default';
        dlBtn.onclick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (!downloadUrl) return;
            const baseTitle = (document.getElementById('modalTitle') && document.getElementById('modalTitle').textContent) ? document.getElementById('modalTitle').textContent : '';
            const suffix = (galleryType === 'backdrops') ? 'backdrop' : 'poster';
            downloadHighRes(downloadUrl, baseTitle, suffix);
        };

        const meta = document.createElement('div');
        meta.className = 'card-meta';
        meta.textContent = `${galleryType === 'backdrops' ? 'Backdrop' : 'Poster'} ${i+1}`;
        card.appendChild(img);
        card.appendChild(dlBtn);
        card.appendChild(meta);
        if (grid) grid.appendChild(card);
    });

    // Setup IntersectionObserver to lazy-load images inside the gallery
    try {
        if (window._galleryObserver) { try { window._galleryObserver.disconnect(); } catch(e){} }
        const rootEl = document.getElementById('galleryInner');
        const imgs = (grid) ? grid.querySelectorAll('img[data-src]') : [];
        const obs = new IntersectionObserver((entries, observer) => {
            entries.forEach(ent => {
                if (ent.isIntersecting) {
                    const el = ent.target;
                    if (el.dataset && el.dataset.src) {
                        el.src = el.dataset.src;
                        el.removeAttribute('data-src');
                    }
                    observer.unobserve(el);
                }
            });
        }, { root: rootEl, rootMargin: '200px', threshold: 0.01 });
        imgs.forEach(iimg => obs.observe(iimg));
        window._galleryObserver = obs;
    } catch(e) { console.warn('gallery lazy observer failed', e); }
}

function closeGallery() {
    const overlay = document.getElementById('galleryOverlay');
    if (!overlay) return;
    overlay.style.display = 'none';
    // clear any grids
    try { const g1 = document.getElementById('galleryGrid'); if (g1) g1.innerHTML = ''; } catch(e){}
    try { const g2 = document.getElementById('galleryGridBackdrop'); if (g2) g2.innerHTML = ''; } catch(e){}
    // disconnect lazy loader observer
    try { if (window._galleryObserver) { window._galleryObserver.disconnect(); window._galleryObserver = null; } } catch(e) {}
}

// Fetch a remote image and trigger a download (works around cross-origin download limitations)
async function downloadHighRes(url, baseTitle, suffix) {
    // maintain counts in-session to avoid duplicate filenames
    window._downloadNameCounts = window._downloadNameCounts || {};
    const base = (typeof baseTitle === 'string' && baseTitle.trim()) ? slugify(baseTitle.trim()) : '';
    const safeSuggested = base ? `${base}_${suffix || 'image'}` : (suffix || 'image');

    // Force extension to jpg for consistency
    const ext = 'jpg';

    // compute unique filename within this session
    const key = `${safeSuggested}.${ext}`;
    const count = window._downloadNameCounts[key] ? window._downloadNameCounts[key] + 1 : 1;
    window._downloadNameCounts[key] = count;
    const filename = count === 1 ? `${safeSuggested}.${ext}` : `${safeSuggested}_${count}.${ext}`;

    try {
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) throw new Error('Network response was not ok');
        const blob = await res.blob();
        const a = document.createElement('a');
        const objectUrl = URL.createObjectURL(blob);
        a.href = objectUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(objectUrl), 1000);
    } catch (err) {
        console.error('Download failed', err);
        // fallback: open in new tab so user can save manually
        try { window.open(url, '_blank'); } catch(e){}
    }
}

function updateGalleryImage() {
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    const idx = Math.max(0, Math.min(window._currentGalleryIndex || 0, gallery.length-1));
    window._currentGalleryIndex = idx;
    const img = document.getElementById('galleryImage');
    if (img) {
        img.src = gallery[idx].original || gallery[idx].medium || gallery[idx].thumb || '';
    }
    // update thumbs active
    const thumbs = document.querySelectorAll('.gallery-thumb');
    thumbs.forEach((t, i) => t.classList.toggle('active', i===idx));
}

function galleryPrev(){
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    window._currentGalleryIndex = (window._currentGalleryIndex - 1 + gallery.length) % gallery.length;
    updateGalleryImage();
}

function galleryNext(){
    const gallery = window._currentGallery || [];
    if (!gallery.length) return;
    window._currentGalleryIndex = (window._currentGalleryIndex + 1) % gallery.length;
    updateGalleryImage();
}

function closeModalIfOutside(event) {
    if (event.target === document.getElementById('modal')) {
        closeModal();
    }
}

function openHelp(){
    document.getElementById('helpModal').style.display = 'block';
}

function closeHelp(){
    document.getElementById('helpModal').style.display = 'none';
}

// Parse querystring on load and open modal if pattern matches ?=id-slug
function parseQueryForMedia(){
    try{
        const q = window.location.search || '';
        const m = q.match(/^\?=(\d+)(?:-([a-z0-9-]+))?/i);
        if(m){
            const id = Number(m[1]);
            if(!isNaN(id)) openModal(id);
        }
    }catch(e){ console.warn('parseQueryForMedia failed', e); }
}

// Handle browser navigation (back/forward).
window.addEventListener('popstate', ()=>{
    try{
        const q = window.location.search || '';
        const m = q.match(/^\?=(\d+)(?:-([a-z0-9-]+))?/i);
        if(m){
            const id = Number(m[1]);
            if(!isNaN(id)) { openModal(id); return; }
        }
    }catch(e){ console.warn('popstate handler failed', e); }
    // no valid id in URL -> close modal
    try{ closeModal(); }catch(e){}
});

window.addEventListener('DOMContentLoaded', ()=>{
    parseQueryForMedia();
});

// Title link: update URL to /trend/ without reloading
function goToTrend(event){
    try{
        if(event) event.preventDefault();
        history.pushState(null,'', '/trend/');
    }catch(e){ console.warn('goToTrend failed', e); }
}

// attach handler if element exists
try{
    const t = document.getElementById('titleLink');
    if(t) t.addEventListener('click', goToTrend);
}catch(e){}
</script>

<script>
  // ‚õîÔ∏è JANGAN TARUH API KEY DI PRODUCTION
  const GEMINI_API_KEY = "AIzaSyBq4plwo8UeTNNZtR2b34RcTIp-AiohlGs";

  async function generateAIContent(){
    const modal = document.getElementById('modalDetails');
    if(!modal){
      alert("Modal tidak ditemukan");
      return;
    }

    const mediaId = modal.getAttribute('data-media-id');
    const mediaType = modal.getAttribute('data-media-type');

    if(!mediaId || !mediaType){
      alert("Data film tidak ditemukan");
      return;
    }

    // Ambil data dari modal
    const title = document.getElementById('modalTitle')?.textContent || "";
    const overview = document.getElementById('modalOverview')?.textContent || "";
    const metaText = document.getElementById('modalMeta')?.innerText || "";

    if(!title || !overview){
      alert("Konten film belum lengkap");
      return;
    }

    const prompt = `
Buatkan konten video short tentang film berikut:

Judul: ${title}
Detail: ${metaText}
Sinopsis: ${overview}

Aturan output:
1. Title maksimal 12 kata, clickbait, tanpa spoiler
2. Description 2‚Äì3 kalimat, bahasa santai
3. 5 hashtag relevan (tanpa simbol # di awal kalimat)

Target: TikTok & YouTube Shorts
Bahasa: Indonesia
Gaya: edukatif + bikin penasaran

WAJIB output JSON VALID tanpa tambahan teks:
{
  "title": "",
  "description": "",
  "hashtags": []
}
`;

    try{
            // Prefer the stable v1 :generate endpoint. If it returns 404, try v1beta2 as a fallback.
            const model = 'gemini-1.5-flash';
            const endpointsToTry = [
                `https://generativelanguage.googleapis.com/v1/models/${model}:generate?key=${GEMINI_API_KEY}`,
                `https://generativelanguage.googleapis.com/v1beta2/models/${model}:generate?key=${GEMINI_API_KEY}`,
                `https://generativelanguage.googleapis.com/v1beta/models/${model}:generate?key=${GEMINI_API_KEY}`
            ];

            let res = null;
            const fetchOptions = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: { text: prompt },
                    // tuning controls (optional)
                    temperature: 0.6,
                    maxOutputTokens: 512
                })
            };

            // Try endpoints in order until one responds without 404
            for (const url of endpointsToTry) {
                try {
                    res = await fetch(url, fetchOptions);
                } catch (e) {
                    console.warn('Fetch to', url, 'failed:', e);
                    res = null;
                }
                if (res && res.status !== 404) break;
            }

            if (!res) throw new Error('Network error calling Gemini endpoints');
            if (!res.ok) {
                const txt = await res.text().catch(() => '');
                throw new Error('HTTP Error ' + res.status + ' - ' + txt);
            }

            const data = await res.json();

            // Extract text from several possible response shapes used by GL APIs
            let rawText = '';
            try {
                const cand = data?.candidates?.[0] || data?.candidate || data?.output?.[0] || null;
                if (cand) {
                    // common shapes
                    if (cand.content && Array.isArray(cand.content)) {
                        // content may contain objects with `text` or `parts`
                        for (const c of cand.content) {
                            if (typeof c === 'string') rawText += c + '\n';
                            else if (c?.text) rawText += c.text + '\n';
                            else if (c?.parts && Array.isArray(c.parts)) rawText += (c.parts.map(p => p.text || '').join('\n')) + '\n';
                        }
                        rawText = rawText.trim();
                    } else if (cand.output && Array.isArray(cand.output)) {
                        rawText = cand.output.map(o => (o.content || []).map(cc => cc.text || '').join('')).join('\n');
                    } else if (typeof cand === 'string') {
                        rawText = cand;
                    } else if (data?.output?.[0]?.content) {
                        rawText = data.output[0].content.map(c=>c.text||'').join('\n');
                    }
                }
            } catch (e) {
                console.warn('Parsing candidate shape failed', e, data);
            }

            if (!rawText) {
                // last resort: stringify entire response for debugging
                console.warn('Unrecognized Gemini response shape:', data);
                throw new Error('Response kosong atau format tidak dikenali dari Gemini');
            }

      // üî• Amankan parsing JSON (kalau Gemini nambah teks)
      const jsonMatch = rawText.match(/\{[\s\S]*\}/);
      if(!jsonMatch){
        console.error("Raw Gemini output:", rawText);
        throw new Error("Format JSON tidak valid");
      }

      const parsed = JSON.parse(jsonMatch[0]);

      document.getElementById('aiTitle').textContent = parsed.title || "-";
      document.getElementById('aiDescription').textContent = parsed.description || "-";
      document.getElementById('aiHashtags').textContent =
        Array.isArray(parsed.hashtags)
          ? parsed.hashtags.map(h => `#${h}`).join(' ')
          : "-";

      document.getElementById('aiResult').style.display = 'block';

    }catch(err){
      console.error("Gemini error:", err);
      alert("Gagal generate AI content. Cek console.");
    }
  }
</script>

</body>
</html>
